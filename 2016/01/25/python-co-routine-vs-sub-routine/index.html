<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content=""><meta name="keyword" content=""><link rel="shortcut icon" href="/img/favicon.ico"><title>[python] 코루틴(co-routine), 서브루틴(sub-routine)과 비교 - 보노의블로그 | Bono&#39;s Blog</title><link rel="canonical" href="http://blueshw.githup.io/2016/01/25/python-co-routine-vs-sub-routine/"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/hux-blog.css"><link rel="stylesheet" href="/css/highlight.css"><link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]--><script></script></head><body ontouchstart=""><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class="container-fluid"><div class="navbar-header page-scroll"><button type="button" class="navbar-toggle"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand" href="/">보노의 블로그</a></div><div id="huxblog_navbar"><div class="navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="/">Home</a></li><li><a href="/about/">About</a></li><li><a href="/archives/">Archives</a></li><li><a href="/tags/">Tags</a></li></ul></div></div></div></nav><script>function handleMagic(e){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic)</script><style type="text/css">header.intro-header{background-image:url(/img/home-bg.jpg)}</style><header class="intro-header"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-heading"><div class="tags"><a class="tag" href="/tags/#python" title="python">python</a> <a class="tag" href="/tags/#co-routine" title="co-routine">co-routine</a></div><h1>[python] 코루틴(co-routine), 서브루틴(sub-routine)과 비교</h1><h2 class="subheading"></h2><span class="meta">Posted by bono on 2016-01-25</span></div></div></div></div></header><article><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container"><p>코루틴의 개념을 살펴보기 전에 우선, 상반되는(반드시 상반된다고는 할 수 없지만..) 서브루틴에 대해서 한번 짚고 넘어가 보겠습니다.<br>참고로 서브루틴의 상반되는 개념은 코루틴이 아닌 메인루틴(main-routine, 그냥 루틴이라고도 함)이라 할 수 있습니다.</p><h3 id="서브루틴"><a href="#서브루틴" class="headerlink" title="서브루틴"></a>서브루틴</h3><p>서브루틴은 반복되는 특정 기능을 모아 별도로 묶어 놓아 이름을 붙여 놓은 것으로 메인루틴을 보조하는 역할을 합니다. 보통 언어에서는 함수나 메소드 등으로 불리며 사용됩니다. 어떤 특정 기능을 모아놓고 이름을 붙였다는 것으로 매크로와 비슷하지만 매크로의 경우 컴파일시에(C언어에서와 같이) 매크로를 호출하는 부분을 모두 매크로 본문으로 대체해 버리므로 메모리 사용이 비효율적입니다. 반면에 서브루틴은 별도의 메모리에 해당 기능을 모아 놓고 있어, 서브루틴이 호출될 때마다 저장된 메모리로 이동했다가 return을 통해 원래 호출자의 위치로 돌아오게 됩니다. 호출할 때마다 매번 같은 위치로 이동하기 때문에 여러번 사용될 수 있으므로 매크로에 비해서 훨씬 효율적이라 할 수 있겠지요.</p><h3 id="코루틴"><a href="#코루틴" class="headerlink" title="코루틴"></a>코루틴</h3><p>코루틴도 서브루틴처럼 기능들을 별도의 공간에 모아 놓고 있다는 점에서는 동일합니다. 차이점이라 할 수 있는 것은, 서브루틴의 경우에는 메인루틴에서 특정 서브루틴의 공간으로 이동한 후에 리턴에 의해 호출자로 돌아와 다시 프로세스를 진행하는데 반해 코루틴의 경우에는 루틴을 진행하는 중간에 멈추어서 특정 위치로 돌아갔다가 다시 원래 위치로 돌아와 나머지 루틴을 수행할 수 있습니다. 또 한가지 차이점은 서브루틴은 진입점과 반환점이 단 하나밖에 없어 메인루틴에 종속적이지만, 코루틴은 진입지점이 여러개이기 때문에 메인루틴에 종속적이지 않아 대등하게 데이터를 주고 받을 수 있다는 특징이 있습니다. 코루틴은 주로 동시성을 필요로 하는 UNITY 등의 게임프로그래밍에서 많이 사용하는 개념이라고 합니다.</p><p>파이썬에도 코루틴이 있습니다.<br>코루틴의 특징과 흐름을 살펴보면 다음과 같습니다.</p><blockquote><ol><li>파이썬에는 yield문이라는 특수한 구문이 있습니다. return 처럼 동작하지만, 사실은 입력으로 동작합니다.(메인루틴에 종속적이 아니라 대등한 상태이기 때문에)</li><li>next(coroutine)은 coroutine 함수의 첫번째 yield까지 호출한다음 대기합니다. 두번째 next(coroutine)을 호출하면, 첫번째 yield 다음의 나머지 부분을 수행하고 다시 돌아와 그 다음 yield까지 호출합니다. iteration이 가능한곳까지 next 함수가 수행된 뒤에는 StopIteration 에러가 발생하게 됩니다.</li><li>만약 yield문이 특정 변수에 할당된다면, 만들어진 코루틴 객체에서 coroutine.send(value)를 호출해 주어야 합니다. 첫번째 coroutine 지점(yield)에 멈춰있는 상태에서 변수에 할당 되어야 하는데 아무런 값도 들어오지 않는다면 에러가 발생하게 됩니다. 즉, yield를 통해서 메인루틴과 서브루틴간에 서로 값이 이동하면서 특정 로직을 수행하게 되는 것입니다.</li></ol></blockquote><p>그럼 예를 살펴보도록 하겠습니다.</p><p>첫번째 예제는 yield 값만 리턴하는 경우입니다. 코루틴 객체를 생성한 후 next() 함수를 통해서 첫번째 yield문에 도달합니다. yield문을 통해 메인루틴에 값을 전달한 후 코루틴 함수는 대기합니다. 다음 next()함수가 호출되면, 멈춰져 있는 yield 부분 다음의 로직을 수행한 다음 한바퀴 돌아 yield 부분에서 또다시 멈추게 됩니다. 아래의 예제에서는 next()를 무한정 호출할 수 있지만, 특정한 조건을 지정해주면 정해진 만큼만 next()를 호출할 수 있습니다. 더이상 호출할 수 없는 코루틴 함수를 next()로 호출하면 예외가 발생하게 됩니다.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">(i)</span></span>:</div><div class="line">    print(<span class="string">'start test1 coroutine'</span>)</div><div class="line">    <span class="keyword">while</span> <span class="symbol">True:</span></div><div class="line">        <span class="keyword">yield</span> i</div><div class="line">        i += <span class="number">1</span></div><div class="line"></div><div class="line">a = test1(<span class="number">5</span>)</div><div class="line"><span class="keyword">next</span>(a)    <span class="comment"># start test1 coroutine 출력 후 5출력, yield i 부분에서 멈춰있다.</span></div><div class="line"><span class="keyword">next</span>(a)    <span class="comment"># 멈춰진 yield i 부분 다음줄의 5 += 1(i=6)을 수행한후 다음 6을 출력하고 yield i에서 멈춘다.</span></div><div class="line"><span class="keyword">next</span>(a)    <span class="comment"># 7을 출력하고 yield i에서 멈춘다.</span></div><div class="line"><span class="keyword">next</span>(a)</div></pre></td></tr></table></figure><p>두번째 예제는 코루틴과 메인루틴이 서로 통신하는 형태입니다. 위의 test1()과 다른점은 yield 구문을 특정 변수에 할당합니다. 이렇게 되면 처음 next()를 호출한 뒤 send(value) 함수를 호출하면 전달된 파라미터가 value에 할당됩니다. 즉, b = test2(5), next(b)를 수행한 뒤 b.send(3)을 호출하면 8이 출력된다는 말이죠. 그 다음은 next()함수와 마찬가지로 그 다음 yield에 가서 멈춰 있게 됩니다.<br>위의 예제와 다른 점은 위 같은 경우에는 코루틴에서 메인루틴으로 일방적으로 값을 전달해줬다면, 아래 예제에서는 메인루틴과 서브루틴이 서로 값을 주고 받는 형태를 이루고 있습니다. 양방향 통신이 가능해진 것이죠. 하지만 실시간으로 서로 주고 받는 형태는 아니므로 반이중 통신이라 할 수 있겠습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">(i)</span>:</span></div><div class="line">    print(<span class="string">'start test2 coroutine'</span>)</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        value = <span class="keyword">yield</span> i </div><div class="line">        i += value</div><div class="line"></div><div class="line">b = test2(<span class="number">5</span>)</div><div class="line">next(b)    <span class="comment"># start test1 coroutine 출력 후 5출력, yield i 부분에서 멈춰있다.</span></div><div class="line">b.send(<span class="number">3</span>)    <span class="comment"># yield를 통해 3을 전달하여 value가 3이 된다. 이후 i += value 줄을 거쳐 i=8이되고 한바퀴 돌아 8을출력, yield에서 멈춘다. </span></div><div class="line">b.send(<span class="number">5</span>)    <span class="comment"># 5를 더해 i는 8이되고 8을 출력한다.</span></div></pre></td></tr></table></figure><p>아직 저도 코루틴을 실제 프로젝트에서 많이 다뤄보지는 못했기에 활용법에 대해서 잘은 모릅니다. 검색을 통해 찾아 보았던 것은 수많은 파이썬 비동기 모듈에서 대부분 코루틴을 다루고 있다는 것입니다. 양 방향으로 통신이 가능하다는 것은 여러 함수를 동시에 호출하면서 서로간에 통신도 가능하다는 말이니 적절한 사용처가 아닐까 생각합니다. 또 생각해 볼 수 있는 것은 정해진 순서가 아닌 사용자의 입력에 따라서 동작이 바뀌는 기계학습 분야에도 많이 활용될 것 같다는 느낌이 드는군요.</p><hr><ul class="pager"><li class="previous"><a href="/2016/02/02/django-setting-for-pycharm-community/" data-toggle="tooltip" data-placement="top" title="[django] pycharm(파이참) community 버전으로 django(장고) 프로젝트 설정">&larr; Previous Post</a></li><li class="next"><a href="/2016/01/22/2016-01-22-python-conditional-ternary-operator/" data-toggle="tooltip" data-placement="top" title="파이썬 3항 연산자 비교">Next Post &rarr;</a></li></ul><div class="comment"><div id="disqus_thread" class="disqus-thread"></div></div></div><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 sidebar-container"><section><h5><a href="/tags/">FEATURED TAGS</a></h5><div class="tags"><a class="tag" href="/tags/#python" title="python">python</a> <a class="tag" href="/tags/#co-routine" title="co-routine">co-routine</a></div></section></div></div></div></article><script type="text/javascript">var disqus_shortname="bonogithub",disqus_identifier="http://blueshw.githup.io/2016/01/25/python-co-routine-vs-sub-routine/",disqus_url="http://blueshw.githup.io/2016/01/25/python-co-routine-vs-sub-routine/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script>function async(e,n){var t=document,a="script",r=t.createElement(a),c=t.getElementsByTagName(a)[0];r.src=e,n&&r.addEventListener("load",function(e){n(null,e)},!1),c.parentNode.insertBefore(r,c)}</script><script>async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){anchors.options={visible:"always",placement:"right",icon:"#"},anchors.add().remove(".intro-header h1").remove(".subheading").remove(".sidebar-container h5")})</script><style>@media all and (min-width:800px){.anchorjs-link{position:absolute;left:-.75em;font-size:1.1em;margin-top:-.1em}}</style><footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a target="_blank" href="https://www.facebook.com/blueshw"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-facebook fa-stack-1x fa-inverse"></i></span></a></li><li><a target="_blank" href="https://github.com/blueshw"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 보노의 블로그 2017<br>Theme by <a href="http://huangxuan.me">Hux</a> <span style="display:inline-block;margin:0 5px"><i class="fa fa-heart"></i> </span>Ported by <a href="http://blog.kaijun.rocks">Kaijun</a> |<iframe style="margin-left:2px;margin-bottom:-5px" frameborder="0" scrolling="0" width="91px" height="20px" src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true"></iframe></p></div></div></div></footer><script src="/js/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/hux-blog.min.js"></script><script>function async(e,n){var t=document,a="script",r=t.createElement(a),c=t.getElementsByTagName(a)[0];r.src=e,n&&r.addEventListener("load",function(e){n(null,e)},!1),c.parentNode.insertBefore(r,c)}</script><script>0!==$("#tag_cloud").length&&async("http://blueshw.githup.io/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js",function(){var c=document.querySelector("nav");c&&FastClick.attach(c)})</script><script>var _gaId="UA-50048807-2",_gaDomain="blueshw.github.io";!function(e,a,n,t,g,o,c){e.GoogleAnalyticsObject=g,e[g]=e[g]||function(){(e[g].q=e[g].q||[]).push(arguments)},e[g].l=1*new Date,o=a.createElement(n),c=a.getElementsByTagName(n)[0],o.async=1,o.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(o,c)}(window,document,"script",0,"ga"),ga("create",_gaId,_gaDomain),ga("send","pageview")</script><img src="http://blueshw.githup.io/img/icon_wechat.png" width="0" height="0"></body></html>