<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="R3ZeY1PmaJUY9j_cgNABjesJFgHWVCJpb4TsdfXntMA"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content=""><meta name="keyword" content=""><link rel="shortcut icon" href="/img/favicon2.ico"><link rel="canonical" href="http://blueshw.github.io/2016/07/26/2016-07-26-functional-programming-in-scala-week2/"><title>Functional Programming in Scala week 2 - 보노의블로그 | Bono&#39;s Blog</title><link rel="canonical" href="http://blueshw.github.io/2016/07/26/2016-07-26-functional-programming-in-scala-week2/"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/hux-blog.css?v=20180409"><link rel="stylesheet" href="/css/highlight.css"><link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]--><script></script></head><body ontouchstart=""><nav class="navbar navbar-default navbar-fixed-top"><div class="container-fluid"><div class="navbar-header page-scroll"><button type="button" class="navbar-toggle"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand" href="/">보노의 블로그</a></div><div id="huxblog_navbar"><div class="navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="/">Home</a></li><li><a href="/about/">About</a></li><li><a href="/tags/">Tags</a></li><li><a href="/archives/">Archives</a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");function handleMagic(e){0<$navbar.className.indexOf("in")?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}$toggle.addEventListener("click",handleMagic)</script><style type="text/css"></style><header class="intro-header"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-heading"><div class="tags"><a class="tag" href="/tags/#scala" title="scala">scala</a> <a class="tag" href="/tags/#coursera" title="coursera">coursera</a></div><h1>Functional Programming in Scala week 2</h1><h2 class="subheading"></h2><span class="meta">Posted by bono on 2016-07-26</span></div></div></div></div></header><article><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container"><h2 id="2-1-Higher-Order-Functions"><a href="#2-1-Higher-Order-Functions" class="headerlink" title="2.1 Higher-Order Functions"></a>2.1 Higher-Order Functions</h2><p>함수형 언어에서는 function이 first-class value이다. 이 말은 특정 함수가 다른 함수의 파라미터나 결과로써 return 될 수 있다는 것이다(higher order functions).</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> sum(f: <span class="keyword">Int</span> =&gt; <span class="keyword">Int</span>, a: <span class="keyword">Int</span>, b: <span class="keyword">Int</span>): <span class="keyword">Int</span> = </span><br><span class="line">  <span class="keyword">if</span> (a &gt; b) <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span> f(a) + sum(f, a+<span class="number">1</span>, b) </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> sumInts(a: <span class="keyword">Int</span>, b: <span class="keyword">Int</span>)       = sum(id, a, b)</span><br><span class="line"><span class="keyword">def</span> sumCubes(a: <span class="keyword">Int</span>, b: <span class="keyword">Int</span>)      = sum(cube, a, b)</span><br><span class="line"><span class="keyword">def</span> sumFactorials(a: <span class="keyword">Int</span>, b: <span class="keyword">Int</span>) = sum(fact, a, b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> id(x: <span class="keyword">Int</span>): <span class="keyword">Int</span> = x</span><br><span class="line"><span class="keyword">def</span> cube(x: <span class="keyword">Int</span>): <span class="keyword">Int</span> = x * x * x</span><br><span class="line"><span class="keyword">def</span> fact(x: <span class="keyword">Int</span>): <span class="keyword">Int</span> = <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> x * fact(x -<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>sum() 함수의 첫번째 파라미터로 f라는 임의의 함수가 들어가 있다.<br>이는 Int 파라미터를 받아서 Int 타입을 리턴하는 함수라면 이 파라미터 위치에 적합하다라는 뜻이다. 즉, 어떠한 함수가 됐든간에 저 유형만 유지하면 된다. 재사용 가능하다는 말이다. 실제로 sumInts(), sumCubes(), sumFactorials() 함수는 모두 sum()함수를 호출한다. sum()함수의 첫번째 파라미터는 각각 id(), cube(), fact()함수를 호출하게 되는데 세 함수 모두 파라미터와 리턴 타입이 Int이므로 sum()함수의 파라미터로 적합하다.</p><h3 id="익명함수"><a href="#익명함수" class="headerlink" title="익명함수"></a>익명함수</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">x</span>: Int, y<span class="symbol">:Int</span>) =&gt; x + y</span><br></pre></td></tr></table></figure><p>익명함수는 보통 함수를 선언하는 방식과는 달리 이름이 없다.<br>대신 파라미터 타입과 body만 존재한다.</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def sumCubes(<span class="name">a</span>: Int, b: Int) = sum(<span class="name">x</span> =&gt; x * x * x, a, b)</span><br></pre></td></tr></table></figure><p>위에서 보았던 sumCubes의 익명함수 버전이다.<br>cube() 함수가 재사용되지 않는다고 가정한다면 매우 심플하기 때문에 따로 함수를 선언하기 보다는 sum() 파라미터에 익명함수로 직접 선언할수 있다.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linear recursion, a와 b의 차이가 커지면 stackOverFlow 익셉션이 발생할 수 있다.</span></span><br><span class="line"><span class="keyword">def</span> sum(f: <span class="keyword">Int</span> =&gt; <span class="keyword">Int</span>, a: <span class="keyword">Int</span>, b: <span class="keyword">Int</span>): <span class="keyword">Int</span> = </span><br><span class="line">  <span class="keyword">if</span> (a &gt; b) <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span> f(a) + sum(f, a+<span class="number">1</span>, b) </span><br><span class="line"></span><br><span class="line"><span class="comment">// tail-recursive version</span></span><br><span class="line"><span class="keyword">def</span> sum(f: <span class="keyword">Int</span> =&gt; <span class="keyword">Int</span>, a: <span class="keyword">Int</span>, b: <span class="keyword">Int</span>): <span class="keyword">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">def</span> loop(a: <span class="keyword">Int</span>, acc: <span class="keyword">Int</span>): <span class="keyword">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) acc</span><br><span class="line">    <span class="keyword">else</span> loop(a+<span class="number">1</span>, f(a)+acc)</span><br><span class="line">  &#125;</span><br><span class="line">  loop(a, <span class="number">0</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-Currying"><a href="#2-2-Currying" class="headerlink" title="2.2 Currying"></a>2.2 Currying</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def sumInts(<span class="name">a</span>: Int, b: Int)       = sum(<span class="name">x</span> =&gt; x, a, b)</span><br><span class="line">def sumCubes(<span class="name">a</span>: Int, b: Int)      = sum(<span class="name">x</span> =&gt; x*x*x, a, b)</span><br><span class="line">def sumFactorials(<span class="name">a</span>: Int, b: Int) = sum(<span class="name">fact</span>, a, b)</span><br></pre></td></tr></table></figure><p>위의 함수들에서 a, b 파라미터는 sumInts(), sum()에서 반복된다. 이를 제거하여 함수를 더 간소하게 만드는 방법은 무엇일까?<br>우선 아래의 함수를 살펴보자.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> sum(f: <span class="keyword">Int</span> =&gt; <span class="keyword">Int</span>): (<span class="keyword">Int</span>, <span class="keyword">Int</span>) =&gt; <span class="keyword">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">def</span> sumF(a: <span class="keyword">Int</span>, b: <span class="keyword">Int</span>): <span class="keyword">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> f(a) + sumF(a+<span class="number">1</span>, b)</span><br><span class="line">  &#125;</span><br><span class="line">  sumF</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>기존에 봤던 sum() 함수와 조금 다르게 생겼다. 우선 sum() 함수의 파라미터가 f() 하나로 줄었고, sum() 함수는 (Int, Int) =&gt; Int 와 같은 타입의 익명함수를 리턴하고 있다.<br>sumF를 호출하는 부분이 조금 이해하기 어려운데, 위의 내부함수 sumF()를 자세히 보면 익명함수를 설명했을 때의 형태와 같다는 것을 알 수 있다.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(x: <span class="keyword">Int</span>, y: <span class="keyword">Int</span>): <span class="keyword">Int</span> =&gt; x * y</span><br><span class="line"><span class="comment">// 이 익명함수는 아래와 같이 표현가능하다.</span></span><br><span class="line"><span class="keyword">def</span> f(x: <span class="keyword">Int</span>): <span class="keyword">Int</span> = x * y; f</span><br></pre></td></tr></table></figure><p>위에서 썼던 sumInts(), sumCubes(), sumFactorials() 함수들을 가져오자. 조금 다르다. sum() 함수의 파라미터가 f 하나로 줄면서 아래의 각 함수들도 sum() 호출부의 인자가 익명함수 하나만 남았다.</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def sumInts(<span class="name">a</span>: Int, b: Int) = sum(<span class="name">x</span> =&gt; x)</span><br><span class="line">def sumCubes(<span class="name">a</span>: Int, b: Int) = sum(<span class="name">x</span> =&gt; x*x*x)</span><br><span class="line">def sumFactorials(<span class="name">a</span>: Int, b: Int) = sum(<span class="name">fact</span>)</span><br></pre></td></tr></table></figure><p>이제 sum() 함수는 함수를 리턴하고 있으므로, sumCubes(1, 10)를 호출하면</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">sumCubes</span><span class="params">(<span class="number">1</span>, <span class="number">10</span>)</span></span></span><br><span class="line"><span class="comment">// res0: (Int, Int) =&gt; Int = &lt;function2&gt;</span></span><br></pre></td></tr></table></figure><p>이는 또한 이렇게 바꿔 쓸수 있다.</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum (<span class="name">cube</span>) (<span class="number">1</span>, <span class="number">10</span>) // multiple parameters</span><br><span class="line">(<span class="name">sum</span> (<span class="name">cube</span>)) (<span class="number">1</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>위의 multiple parameters를 적용하면 sum() 함수를 더 짧게 작성할 수 있다.</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def <span class="built_in">sum</span>(f: <span class="built_in">Int</span> =&gt; <span class="built_in">Int</span>)(a: <span class="built_in">Int</span>, b: <span class="built_in">Int</span>): <span class="built_in">Int</span> =</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b) <span class="number">0</span> <span class="keyword">else</span> f(a) + <span class="built_in">sum</span>(f)(a+<span class="number">1</span>, b)</span><br></pre></td></tr></table></figure><p>여러개의 파라미터 list를 가진 함수 f에서 파라미터list의 개수가 1보다 큰 경우 마지막 파라미터 list를 f 함수에서 제거하면 이 마지막 파라미터 list를 파라미터로 가지는 또다른 함수 g를 만들 수 있다. 물론 이 g 함수는 f 함수의 리턴함수가 된다. 식으로 나타내면 다음과 같다. 참고로 각각의 식은 모두 동일하다</p><figure class="highlight flix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(arg1)(arg2)(arg3)(arg4) = E</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(arg1)(arg2)(arg3) = &#123;<span class="function"><span class="keyword">def</span> <span class="title">g</span></span>(arg4) = E;g&#125; <span class="comment">// arg4를 이용해 g함수 생성</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(arg1)(arg2)(arg3) = (arg4 =&gt; E) <span class="comment">// g를 익명함수로 변경</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span> </span>= (arg1 =&gt; (arg2 =&gt; (arg3 =&gt; (arg4 =&gt; E)))) <span class="comment">// 파라미터를 하나씩 우측으로 전달함</span></span><br></pre></td></tr></table></figure><p>이와같은 형태의 함수정의를 curring 이라 부른다.</p><h3 id="Excercise"><a href="#Excercise" class="headerlink" title="Excercise"></a>Excercise</h3><p><em>Write a product function that calculates the product of the values of a function for the points on a given interval</em></p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def <span class="built_in">product</span>(f: <span class="built_in">Int</span> =&gt; <span class="built_in">Int</span>)(a: <span class="built_in">Int</span>, b: <span class="built_in">Int</span>): <span class="built_in">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b) <span class="number">1</span> <span class="keyword">else</span> f(a) * <span class="built_in">product</span> (f)(a+<span class="number">1</span>, b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">product</span>(x =&gt; x*x)(<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><em>Write factorial in terms of product.</em></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def <span class="built_in">fact</span>(<span class="symbol">n:</span> <span class="built_in">Int</span>)<span class="symbol">:</span> <span class="built_in">Int</span> = <span class="built_in">product</span>(x =&gt; x)(<span class="number">1</span>, <span class="built_in">n</span>)</span><br><span class="line"><span class="built_in">fact</span>(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><em>Can you write a more general funciton, which generalizes both sum and product?</em></p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def mapReduce(f: <span class="keyword">Int</span> =&gt; <span class="keyword">Int</span>, combine: (<span class="keyword">Int</span>, <span class="keyword">Int</span>) =&gt; <span class="keyword">Int</span>, zero: <span class="keyword">Int</span>)(a: <span class="keyword">Int</span>, b: <span class="keyword">Int</span>): <span class="keyword">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b) zero</span><br><span class="line">  <span class="keyword">else</span> combine(f(a), mapReduce(f, combine, zero)(a+<span class="number">1</span>, b))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def productForMapReduce(f: <span class="keyword">Int</span> =&gt; <span class="keyword">Int</span>)(a: <span class="keyword">Int</span>, b: <span class="keyword">Int</span>): <span class="keyword">Int</span> = mapReduce(f, (x, y) =&gt; x*y, <span class="number">1</span>)(a, b)</span><br><span class="line">productForMapReduce(x =&gt; x*x)(<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h2 id="2-3-Example-Finding-Fixed-Point"><a href="#2-3-Example-Finding-Fixed-Point" class="headerlink" title="2.3 Example: Finding Fixed Point"></a>2.3 Example: Finding Fixed Point</h2><p>부동점 구하기, Fixed Point라 함은 어떤 함수에서 고정적인 값을 갖는 point를 말한다. 다음의 함수에서 2는 부동점(고정점)이다.<br>기하학적으로(?) 함수 f의 부동점은 y = x 와 주어진 함수와의 교점이다. 즉, x와 f(x) 값이 동일한 값을 뜻한다.</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(x) = x^<span class="number">2</span> <span class="number">-3</span>x + <span class="number">4</span></span><br><span class="line"><span class="comment">// 2 = 4 - 6 + 4</span></span><br><span class="line"><span class="comment">// 2 = 2, 부동점</span></span><br></pre></td></tr></table></figure><p>어떤 함수에 대해서 부동점을 구하는 함수 fixedPoint는 아래와 같다.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">object ex &#123;</span><br><span class="line">  val tolerance = <span class="number">0</span>.<span class="number">0001</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isCloseEnough</span><span class="params">(<span class="symbol">x:</span> Double, <span class="symbol">y:</span> Double)</span></span> =</span><br><span class="line">    abs((x - y) / x) / x &lt; tolerance</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fixedPoint</span><span class="params">(<span class="symbol">f:</span> Double =&gt; Double)</span></span>(<span class="symbol">firstGuess:</span> Double) = &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iterate</span><span class="params">(<span class="symbol">guess:</span> Double)</span></span>: Double = &#123;</span><br><span class="line">      println(<span class="string">"guess = "</span> + guess)</span><br><span class="line">      val <span class="keyword">next</span> = f(guess)</span><br><span class="line">      <span class="keyword">if</span> (isCloseEnough(guess, <span class="keyword">next</span>)) <span class="keyword">next</span></span><br><span class="line">      <span class="keyword">else</span> iterate(<span class="keyword">next</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    iterate(firstGuess)</span><br><span class="line">  &#125;</span><br><span class="line">  fixedPoint(x =&gt; <span class="number">1</span> + x/<span class="number">2</span>)(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sqrt</span><span class="params">(<span class="symbol">x:</span> Double)</span></span> = fixedPoint(y =&gt; x / y)(<span class="number">1</span>)</span><br><span class="line">  sqrt(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fixedPoint를 응용해보면, 첫번째 인자인 f 함수에 어떤 수식을 넣어 반복적으로 적용하면서 고정값을 찾아 가는 과정에 맞게 넣을 수 있겠다.<br>마지막에 있는 것은 sqrt를 구하는 함수는 바로 위에서 말한 반복을 통한 고정값 추론에 적합하다.<br>sqrt y를 구하려면 y * y = x가 되기 때문에 함수 y = x / y를 fixedPoint 함수에 반복적으로 적용하다보면 고정값 sqrt의 근사치를 구할 수 있다.<br>하지만, 실제로 위와같이 y =&gt; x / y를 fixedPoint의 함수 인자로 넣게 되면, 원하는 값을 얻지 못한다.<br>왜냐하면, guess 값이 너무 심하게 변하기 때문에 발생하는 문제다. fixedPoint 의 내부함수 iterate는 guess와 next가 교차하는 구조인데, 처음 sqrt(2)에서 2는 x이다.<br>그리고 y는 firstGuess 인 1이되는데, 이 두 값이 f(x) = x / y에 대입되면, f(x)는 2가 된다. 다시 y가 2가 되고 x가 2이므로 iterate 함수를 한번 돌면 y는 1이된다.<br>즉, 1,2,1,2 반복하기 때문에 무한루프에 빠지게 된다.<br>이를 해결하기 위해서는 연속하는 두개의 값 즉 1과 2의 평균값(1.5)를 구함으로써 해결할 수 있다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">y =&gt; x / y</span><br><span class="line"><span class="comment">// 아래와 같이 바꿔 쓴다.</span></span><br><span class="line">y =&gt; (y + x<span class="regexp">/y) /</span> <span class="number">2</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 코드에 적용해보면</span></span><br><span class="line"><span class="keyword">def</span> sqrt(<span class="string">x:</span> Double) = fixedPoint(y =&gt; (y + x <span class="regexp">/ y) /</span> <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>위와 같이 평균을 내어서 안정화 시키는 기법을 AverageDamp라고 한다.</p><h2 id="2-4-Scala-Syntax-Summary"><a href="#2-4-Scala-Syntax-Summary" class="headerlink" title="2.4 Scala Syntax Summary"></a>2.4 Scala Syntax Summary</h2><p>강의 참고</p><h2 id="2-5-Functions-and-Data"><a href="#2-5-Functions-and-Data" class="headerlink" title="2.5 Functions and Data"></a>2.5 Functions and Data</h2><p>유리수의 여러가지 연산을 바탕으로 함수를 만드는 방법과 데이터를 캡슐화하기 위해 클래스를 사용하는 방법을 알아 본다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">x: <span class="type">Int</span>, y: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numer</span> </span>= x</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">denom</span> </span>= y</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(that: <span class="type">Rational</span>) =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Rational</span>(</span><br><span class="line">      numer * that.denom + that.numer * denom,</span><br><span class="line">      denom * that.denom)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// object</span></span><br><span class="line"><span class="keyword">val</span> x = <span class="keyword">new</span> <span class="type">Rational</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">x.numer  <span class="comment">// 1</span></span><br><span class="line">y.denom  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>위에서 Rational 클래스를 정의하였다. 클래스를 정의하면 두가지 요소가 정의되는데, 첫번째는 Rational이라는 type이 만들어진다는 것이고, 두번째는 x와 y를 인자로 가지는 Rational이라는 생성자가 만들어진다는 것이다.<br>object를 만드는 법은 Java의 object 만드는 법과 동일하게 new 키워드를 사용해서 만들 수 있다.</p><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>스칼라에서 함수(funciton)과 메소드(method)는 다른 의미로 사용되는데, 일반적으로 함수는 독립적인 객체로서 클래스처럼 인스턴스화 가능한 형태로 동작하는 반면, 메소드는 클래스내에 속하는 멤버로써 클래스 내의 데이터를 연산하는 역할을 한다. 실제 컴파일 해보면 차이를 알 수 있는데, 함수같은 경우에는 클래스로 변경되어 있지만(내부 함수인 경우에는 내부 클래스로 컴파일), 메소드는 컴파일 내에 멤버로만 존재하기 때문에 별도의 class로 컴파일 되지 않는다.</p><h3 id="Exerxise"><a href="#Exerxise" class="headerlink" title="Exerxise"></a>Exerxise</h3><ol><li><p>In your worksheet, add a method neg to class Rational that is used like this: x.neg</p></li><li><p>Add a method sub to subtract two rational numbers.</p></li><li><p>With the values of x, y, z as given in the previous slide, what is the result of x - y - z</p></li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">x: <span class="type">Int</span>, y: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numer</span> </span>= x</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">denom</span> </span>= y</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(that: <span class="type">Rational</span>) =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Rational</span>(</span><br><span class="line">      numer * that.denom + denom * that.numer,</span><br><span class="line">      denom * that.denom)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">neg</span></span>: <span class="type">Rational</span> = <span class="keyword">new</span> <span class="type">Rational</span>(numer * <span class="number">-1</span>, denom)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sub</span></span>(that: <span class="type">Rational</span>): <span class="type">Rational</span> = add(that.neg)</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= numer + <span class="string">"/"</span> + denom</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> x = <span class="keyword">new</span> <span class="type">Rational</span>(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> y = <span class="keyword">new</span> <span class="type">Rational</span>(<span class="number">5</span>, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">val</span> z = <span class="keyword">new</span> <span class="type">Rational</span>(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">x.sub(y).sub(z) <span class="comment">// res0: Rational = -79/42</span></span><br></pre></td></tr></table></figure><h2 id="2-6-More-Fun-With-Rationals"><a href="#2-6-More-Fun-With-Rationals" class="headerlink" title="2.6 More Fun With Rationals"></a>2.6 More Fun With Rationals</h2><p>2.5에서 구현한 Rational 클래스는 분모와 분자를 나누어진 형태로 출력하지 않는 문제가 있다. 그래서 이전에 사용했었던 최대 공약수를 구하는 함수인 gcd를 메서드 형태로 Rational 클래스에 추가해준다.<br>그리고 클래스의 인수인 x와 y에 두 변수의 gcd 값을 나누어준다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">x: <span class="type">Int</span>, y: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">gcd</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> = <span class="keyword">if</span> (b == <span class="number">0</span>) a <span class="keyword">else</span> gcd(b, a % b)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ex 1) g를 재사용하는 방법</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> g = gcd(x, y)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numer</span> </span>= x / g </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">denom</span> </span>= y / g</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ex 2) numer와 denom이 자주 호출되지 않을때는 gcd를 직접 넣어줌</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numer</span> </span>= x / gcd(x, y)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">denom</span> </span>= y / gcd(x, y)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ex3) 이 두 변수는 한번만 연산하도록 하기 위해 메서드를 value로 변경, numer와 denom이 자주 call 되는 경우에 적합 </span></span><br><span class="line">  <span class="keyword">val</span> numer = x / gcd(x, y)</span><br><span class="line">  <span class="keyword">val</span> denom = y / gcd(x, y)</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this 키워드는 java와 동일하게 사용된다. this는 현재 메소드가 실행되고있는 object를 말한다. second 생성자를 만들때에도</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def <span class="keyword">this</span>(x: <span class="built_in">Int</span>) = <span class="keyword">this</span>(x, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>과 같이 사용한다.</p><h3 id="require-키워드"><a href="#require-키워드" class="headerlink" title="require 키워드"></a>require 키워드</h3><p>require 키워드를 사용하면 클래스의 인자값 등에 대한 제약을 만들 수 있다. 아래의 클래스가 있는 상태에서 만약에 new Rational(1, 0)과 같은 instance를 생성하게 되면 예외가 발생하게 된다. require와 같이 객체가 생성될때 강제로 호출하는 역할을 하는 함수를 predefined funciton 이라고 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span>(x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span>) &#123;</span><br><span class="line">  require(y != <span class="number">0</span>, <span class="string">" denominator must be positive"</span>)  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-7-Evaluation-and-Operators"><a href="#2-7-Evaluation-and-Operators" class="headerlink" title="2.7 Evaluation and Operators"></a>2.7 Evaluation and Operators</h2><p>클래스와 메소드의 evalutaion 과정</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class C(x1, <span class="params">...</span>, xm) &#123;<span class="params">...</span> def f(y1, <span class="params">...</span>, yn) = b <span class="params">...</span>&#125;</span><br><span class="line"><span class="literal">new</span> C(v1, <span class="params">...</span>, vm).f(w1, <span class="params">...</span>, wn)</span><br><span class="line"></span><br><span class="line"><span class="comment">// substitution</span></span><br><span class="line"><span class="meta">[</span>w1/y1, <span class="params">...</span> wn/yn<span class="meta">]</span><span class="meta">[</span>v1/x1, <span class="params">...</span>, vm/xm<span class="meta">]</span><span class="meta">[</span><span class="literal">new</span> C(v1, <span class="params">...</span>, vm)/this<span class="meta">]</span>b</span><br></pre></td></tr></table></figure><p>과정을 간단히 요약하면</p><ol><li>f 메서드의 formal parameters(y1, …, yn)이 arguments(w1, …, wn)으로 치환</li><li>클래스의 formal parameters(x1, …, xm)이 arguments(v1, …, vm)으로 치환</li><li>self reference this가 new C(v1, …, vm)으로 치환</li></ol><p>만약 f 함수 내부에서 this 가 사용된다고 가정한다면, 이 this는 이미 new C(v1, …, vm)으로 치환된 value 이므로, 해당 object 자체를 참조하는 값이 된다.</p><h3 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h3><p>일반적인 언어에서는 r.add(s)와 같은 함수가 호출될때 자연수인 경우에는 r + s와 같이 바꿔 쓸 수 있지만, 유리수의 경우에는 불가하다.<br>하지만 스칼라에서는 오퍼레이터 기호를 함수 이름으로 사용가능하다.</p><ul><li>step 1 : r.add(s) ==&gt; r add s</li><li>step 2 : def + (that: Rational) = { … }</li></ul><p>하지만 위와 같이 함수 이름을 오퍼레이터로 사용하게 되면, 우선순위 문제가 발생할 수 있다.<br>그래서 스칼라에서는 precedence rules을 별도로 만들어 두었다.<br>우선순위는 아래가 제일 높고 위로 갈수록 낮아진다.</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(all letters)</span><br><span class="line">|</span><br><span class="line">^</span><br><span class="line">&amp;</span><br><span class="line">&lt; &gt;</span><br><span class="line"><span class="section">= !</span></span><br><span class="line">:</span><br><span class="line">+ -</span><br><span class="line"><span class="bullet">* </span>/ %</span><br><span class="line">(all other special characters)</span><br></pre></td></tr></table></figure><hr><ul class="pager"><li class="previous"><a href="/2016/07/26/2016-07-26-functional-programming-in-scala-week3/" data-toggle="tooltip" data-placement="top" title="Functional Programming in Scala week 3">&larr; Previous Post</a></li><li class="next"><a href="/2016/07/26/2016-07-26-functional-programming-in-scala-week1/" data-toggle="tooltip" data-placement="top" title="Functional Programming in Scala week 1">Next Post &rarr;</a></li></ul><div class="comment"><div id="disqus_thread" class="disqus-thread"></div></div></div><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 sidebar-container"><section><h5><a href="/tags/">FEATURED TAGS</a></h5><div class="tags"><a class="tag" href="/tags/#scala" title="scala">scala</a> <a class="tag" href="/tags/#coursera" title="coursera">coursera</a></div></section></div></div></div></article><script type="text/javascript">var disqus_shortname="bonogithub",disqus_identifier="http://blueshw.github.io/2016/07/26/2016-07-26-functional-programming-in-scala-week2/",disqus_url="http://blueshw.github.io/2016/07/26/2016-07-26-functional-programming-in-scala-week2/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a target="_blank" href="https://twitter.com/blueshw" rel="external nofollow noopener noreferrer"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-twitter fa-stack-1x fa-inverse"></i></span></a></li><li><a target="_blank" href="https://www.facebook.com/blueshw" rel="external nofollow noopener noreferrer"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-facebook fa-stack-1x fa-inverse"></i></span></a></li><li><a target="_blank" href="https://github.com/blueshw" rel="external nofollow noopener noreferrer"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 보노의 블로그 2018</p></div></div></div></footer><script src="/js/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/hux-blog.min.js"></script><script>function async(e,n){var t=document,a="script",r=t.createElement(a),c=t.getElementsByTagName(a)[0];r.src=e,n&&r.addEventListener("load",function(e){n(null,e)},!1),c.parentNode.insertBefore(r,c)}</script><script>0!==$("#tag_cloud").length&&async("http://blueshw.github.io/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js",function(){var c=document.querySelector("nav");c&&FastClick.attach(c)})</script><script>var _gaId="UA-50048807-2",_gaDomain="blueshw.github.io";!function(a,e,g,n,t,o,c){a.GoogleAnalyticsObject="ga",a.ga=a.ga||function(){(a.ga.q=a.ga.q||[]).push(arguments)},a.ga.l=1*new Date,o=e.createElement(g),c=e.getElementsByTagName(g)[0],o.async=1,o.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(o,c)}(window,document,"script"),ga("create",_gaId,_gaDomain),ga("send","pageview")</script><img src="http://blueshw.github.io/img/icon_wechat.png" width="0" height="0"></body></html>