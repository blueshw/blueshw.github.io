<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content=""><meta name="keyword" content=""><link rel="shortcut icon" href="/img/favicon.ico"><title>Functional Programming in Scala week 4 - 보노의블로그 | Bono&#39;s Blog</title><link rel="canonical" href="http://blueshw.githup.io/2016/07/26/2016-07-26-functional-programming-in-scala-week4/"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/hux-blog.css"><link rel="stylesheet" href="/css/highlight.css"><link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]--><script></script></head><body ontouchstart=""><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class="container-fluid"><div class="navbar-header page-scroll"><button type="button" class="navbar-toggle"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand" href="/">보노의 블로그</a></div><div id="huxblog_navbar"><div class="navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="/">Home</a></li><li><a href="/about/">About</a></li><li><a href="/archives/">Archives</a></li><li><a href="/tags/">Tags</a></li></ul></div></div></div></nav><script>function handleMagic(e){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic)</script><style type="text/css">header.intro-header{background-image:url(/img/home-bg.jpg)}</style><header class="intro-header"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-heading"><div class="tags"><a class="tag" href="/tags/#scala" title="scala">scala</a> <a class="tag" href="/tags/#coursera" title="coursera">coursera</a></div><h1>Functional Programming in Scala week 4</h1><h2 class="subheading"></h2><span class="meta">Posted by bono on 2016-07-26</span></div></div></div></div></header><article><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container"><h2 id="4-1-Objects-Everywhere"><a href="#4-1-Objects-Everywhere" class="headerlink" title="4.1 Objects Everywhere"></a>4.1 Objects Everywhere</h2><blockquote><p>퓨어 object-oriented 언어란 모든 value가 object라는 말인데, 그렇다면 스칼라가 퓨어 object-oriented language인가?</p></blockquote><p>스칼라의 모든 값은 object로 표현되기 때문에 퓨어하다 할 수 있다. 예로 scala.Boolean 대신 커스텀으로 Boolean 클래스를 정의한다(자바의 래핑클래스(Integer 등)처럼)</p><p>Boolean 클래스에서는 실제 스칼라 Boolean으로 사용할 수 있었던 연산을 모두 재정의해준다.<br>ifThenElse는 if(cond) f1 else f2과 같다(여기서 f1, f2는 ifThenElse의 파라미터)<br>아래는 ‘&lt;’ 함수를 정의한 예제이다.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">claass <span class="keyword">Boolean</span> &#123;</div><div class="line">  ...</div><div class="line">  <span class="keyword">def</span> &lt; (x: <span class="keyword">Boolean</span>): <span class="keyword">Boolean</span> = ifThenElse(<span class="keyword">false</span>, x)</div><div class="line"> &#125;</div></pre></td></tr></table></figure><h2 id="4-2-Functions-as-Objects"><a href="#4-2-Functions-as-Objects" class="headerlink" title="4.2 Functions as Objects"></a>4.2 Functions as Objects</h2><p>스칼라에서는 function values는 오브젝트로 취급된다. 사실 function type A =&gt; B는 scala.Function1[A, B]의 축약 형태와 같다고 할수 있다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> scala</div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function1</span>[<span class="title">A</span>, <span class="title">B</span>] &#123;</span></div><div class="line">  <span class="keyword">def</span> aaply(<span class="string">x:</span> A): B</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>즉, 함수는 apply 메소드를 가진 오브젝트와 같다.<br>익명함수의 경우에는 다음과 같이 확장될 수 있다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(x: <span class="type">Int</span>) =&gt; x * x</div><div class="line"></div><div class="line"><span class="comment">// is expanded to</span></div><div class="line">&#123; <span class="class"><span class="keyword">class</span> <span class="title">AnonFun</span> <span class="keyword">extends</span> <span class="title">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">Int</span>) = x * x</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">new</span> <span class="type">AnonFun</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// shorter</span></div><div class="line"><span class="keyword">new</span> <span class="type">FUnctino1</span>[<span class="type">Int</span>, <span class="type">Int</span>] &#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">Int</span>) = x * x</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>그러니까 실제로 f(a, b) 라는 함수를 call 했을 때, f.apply(a, b)가 불리는 것과 같다는 말이다.<br>예를 들면,</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">val f = (x: <span class="built_in">Int</span>) =&gt; x * x</div><div class="line">f(<span class="number">7</span>)</div><div class="line"></div><div class="line">val f = new <span class="function"><span class="keyword">Function</span></span>[<span class="built_in">Int</span>. <span class="built_in">Int</span>] &#123;</div><div class="line">  def apply(x: <span class="built_in">Int</span>) = x * x</div><div class="line">&#125;</div><div class="line">f.apply(<span class="number">7</span>)</div></pre></td></tr></table></figure><p>위에서 본것처럼 apply 메소드는 오브젝트 안에 있을 때 오브젝트 이름 그대로 호출할 수 있다. 지난번에 봤던 List를 예로 들어보면 아래와 같다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">List</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">T</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">List</span>[<span class="type">T</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cons</span>[<span class="type">T</span>](<span class="params">val head: <span class="type">T</span>, val tail: <span class="type">List</span>[<span class="type">T</span>]</span>) <span class="keyword">extends</span> <span class="title">List</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span> </span>= <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nil</span>[<span class="type">T</span>] <span class="keyword">extends</span> <span class="title">List</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">Nothing</span> = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span>(<span class="string">"Nil.head"</span>)</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">Nothing</span> = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span>(<span class="string">"Nil.tail"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// List()</span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">List</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>]: <span class="type">List</span>[<span class="type">T</span>] = <span class="keyword">new</span> <span class="type">Nil</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](x: <span class="type">T</span>): <span class="type">List</span>[<span class="type">T</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(x, <span class="keyword">new</span> <span class="type">Nil</span>)</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](x1: <span class="type">T</span>, x2: <span class="type">T</span>): <span class="type">List</span>[<span class="type">T</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(x1, <span class="keyword">new</span> <span class="type">Cons</span>(x2, <span class="keyword">new</span> <span class="type">Nil</span>))</div><div class="line">  </div><div class="line">  <span class="comment">// objectd 이름 그대로 호출 가능, 파라미터가 맞는 apply 메소드를 알아서 찾아감</span></div><div class="line">  <span class="keyword">val</span> a = <span class="type">List</span>()</div><div class="line">  <span class="keyword">val</span> b = <span class="type">List</span>(<span class="number">1</span>)</div><div class="line">  <span class="keyword">val</span> c = <span class="type">List</span>(<span class="number">2</span>, <span class="number">3</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-3-Subtyping-and-Generics"><a href="#4-3-Subtyping-and-Generics" class="headerlink" title="4.3 Subtyping and Generics"></a>4.3 Subtyping and Generics</h2><p>스칼라 언어에서 다형성을 표현하는 두가지 방법은 subtyping과 generic 이다.</p><h3 id="Type-Bounds"><a href="#Type-Bounds" class="headerlink" title="Type Bounds"></a>Type Bounds</h3><blockquote><p>takes an IntSet<br>returns the IntSet itself if all this elements are positive<br>throws an exception otherwise</p></blockquote><p>위의 세가지 조건을 충족시킬 수 있는 함수를 생각해보자.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">assertAllPos</span><span class="params">(<span class="symbol">s:</span> IntSet)</span></span>: IntSet</div></pre></td></tr></table></figure><p>대부분의 경우는 위의 함수로 충분하지만 정확히 하자면 다음과 같이 쓸수 있다.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">def assertAllPos[<span class="string">S &lt;: IntSet</span>](<span class="link">r: S</span>): S = ...</div></pre></td></tr></table></figure><p>“S &lt;: IntSet”을 type parameter S의 upper bound라고 한다. 이것은 S가 반드시 IntSet의 subType(또는 자신)이어야 한다는 말과 같다.<br>반대로 “S :&gt; T”는 S가 T의 superType이거나 T가 S의 subType이라는 말이다. 이를 lower Bounds 라고 한다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[S &gt;: NonEmpty]</div></pre></td></tr></table></figure><p>위에서 말했듯이 위의 의미는 S가 NonEmpty 클래스의 supertype인데, S는 NonEmpty의 모든 base 클래스(자신 포함)가 해당된다. 여기서 S는 NonEmpty, IntSet, AnyRef, Any가 될 수 있다.</p><p>마지막은 Mixed Bound</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[S &gt;: NonEmpty &lt;: IntSet]</div></pre></td></tr></table></figure><p>이것의 의미는 S가 NonEmtpy와 IntSet 타입 사이의 모든 타입이 될 수 있다는 말과 같다.</p><h3 id="Covariance"><a href="#Covariance" class="headerlink" title="Covariance"></a>Covariance</h3><p>서브클래스의 인스턴스 컬렉션을 상위클래스의 컬렉션으로 보내는 것을 Covariance(공변성)라고 한다. 왜냐하면 subtyping 관계가 컬렉션에서도 그대로 적용되었기 때문이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NonEmpty <span class="type">&lt;:</span> <span class="built_in">IntSet</span></div><div class="line">// 위가 성립된다면 아래도 성립</div><div class="line">List[NonEmpty] <span class="type">&lt;:</span> List[<span class="built_in">IntSet</span>]</div></pre></td></tr></table></figure><h3 id="Arrays-in-Scala"><a href="#Arrays-in-Scala" class="headerlink" title="Arrays in Scala"></a>Arrays in Scala</h3><figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">T[]     <span class="comment">// Java</span></div><div class="line"><span class="keyword">Array</span>[T]  <span class="comment">// Scala</span></div><div class="line"></div><div class="line"><span class="comment">// Covariance에 의해 아래가 성립</span></div><div class="line">NonEmpty[] &lt;: IntSet[]        <span class="comment">// Java</span></div><div class="line"><span class="keyword">Array</span>[NonEmpty] &lt;: <span class="keyword">Array</span>[IntSet]  <span class="comment">// Scala</span></div></pre></td></tr></table></figure><p>자바의 Array Typing에는 타입과 관련된 아래의 문제가 있다.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NonEmpty[] <span class="selector-tag">a</span> = new NonEmpty[]&#123;new NonEmpty(<span class="number">1</span>, Empty, Empty)&#125;</div><div class="line">IntSet[] <span class="selector-tag">b</span> = <span class="selector-tag">a</span></div><div class="line"><span class="selector-tag">b</span>[<span class="number">0</span>] = Empty</div><div class="line">NonEmpty s = <span class="selector-tag">a</span>[<span class="number">0</span>]</div></pre></td></tr></table></figure><p>a는 NonEmpty 타입의 Array를 가리키는 포인터이다. 두번째 줄에서 IntSet Array b 에 a를 대입하였다. b가 실제로 카리키는 대상은 NonEmpty List지만, covariance 규칙에 의해 상위 타입의 컬렉션이 하위 타입의 컬렉션을 대신할 수 있다. 세번째 줄에서 b의 첫번째 item에 Empty 클래스를 대입하였다. 마지막으로 a의 첫번째 item을 NonEmpty 타입의 s에 대입하였다. b와 a 는 실제로 가리키는 대상이 같기 때문에 세번째 줄에서 b[0]에 들어간 Empty는 a[0]에서도 동일하게 작동한다. 그런데 마지막 줄에서 Empty 타입의 item 을 NonEmpty 타입에 할당하기 때문에 런타임 에러가 발생한다.</p><h3 id="Liskov-Substitution-Principle"><a href="#Liskov-Substitution-Principle" class="headerlink" title="Liskov Substitution Principle"></a>Liskov Substitution Principle</h3><blockquote><p>If A &lt;: B, then everything one can to do with a value of type B one should also be able to do with a value of type A<br>리스코프 치환원칙은 타입 A와 B가 있을때 하나의 타입이 다른 하나의 서브타입이 될 수 있는 조건에 대해 말해준다.</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in scala</span></div><div class="line">val <span class="selector-tag">a</span>: Array[NonEmpty] = Array(new NonEmpty(<span class="number">1</span>, Empty, Empty))</div><div class="line">val <span class="selector-tag">b</span>: Array[IntSet] = <span class="selector-tag">a</span></div><div class="line"><span class="function"><span class="title">b</span><span class="params">(<span class="number">0</span>)</span></span> = Empty</div><div class="line">val s: NonEmpty = a(<span class="number">0</span>)</div></pre></td></tr></table></figure><p>스칼라의 경우에는 두번째 줄에서 컴파일 에러가 난다. 그 이유는 스칼라의 Array는 covariant하지 않기 때문이다. (NonEmpty )</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NonEmpty <span class="type">&lt;:</span> <span class="built_in">IntSet</span></div><div class="line">not <span class="built_in">Array</span>[NonEmpty] <span class="type">&lt;:</span> <span class="built_in">Array</span>[<span class="built_in">IntSet</span>]</div></pre></td></tr></table></figure><h2 id="4-4-Variance"><a href="#4-4-Variance" class="headerlink" title="4.4 Variance"></a>4.4 Variance</h2><p>스칼라에서 List는 covariant, Array는 성립하지 않는다. 그 이유는 list의 경우에는 immutable한 컬렉션이고, Array는 mutable 하기 때문이다. 보통 mutation을 허용하는 타입은 covariant하지 않다.</p><p>C[T]에서 A &lt;: B인 경우 다음이 성립한다.<br>B가 A의 수퍼타입이면서 C[B]가 C[A]의 수퍼타입인 경우에는 covariant, C[A]가 C[B]의 수퍼타입이면 contravariant</p><ul><li>C[A] &lt;: C[B] 이면 C는 covariant (class C[+A])</li><li>C[A] &gt;: C[B] 이면 C는 contravariant (class C[-A])</li><li>C[A]와 C[B] 둘다 다른것의 서브타입이 아니면 C는 nonvariant (class C[A])</li></ul><p>다음의 두 타입중 어떤 타입이 수퍼타입이고, 어떤 타입이 서브타입인가?<br>함수의 파라미터가 더 구체적인(서브타입) 타입이 들어 갔을때는 반드시 그 타입으로 인자가 넘어와야한다. type B를 보면 파라미터 타입이 IntSet의 서브타입인 NonEmpty이므로 인자가 반드시 NonEmpty 타입이어야 한다. 반면에 type A를 보면, 파라미터 타입이 IntSet이라 NonEmpty 포함 IntSet의 모든 서브타입이 들어 올 수 있다. 리턴타입은 NonEmpty이므로 IntSet이라 할 수 있다. 즉, A는 B의 규칙을 만족시킨다. 게다가 A는 파라미터에 추가로 Empty 같은 타입이 들어 올 수 있으므로, A가 B보다 더 확장된 형태이다.<br>그러므로, B가 A의 수퍼타입이다. 함수의 파라미터는 contravariant하고 함수의 리턴값은 covariant 하기 때문에 A &lt;: B가 참이다.</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> <span class="type">A </span>= IntSet =&gt; NonEmpty</div><div class="line"><span class="keyword">type</span> <span class="type">B </span>= NonEmpty =&gt; IntSet</div></pre></td></tr></table></figure><p>위의 내용을 요약하면 아래와 같다.</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">If</span> <span class="built_in">A2</span> &lt;: <span class="built_in">A1</span> <span class="keyword">and </span><span class="keyword">B1 </span>&lt;: <span class="keyword">B2, </span>then</div><div class="line">  <span class="built_in">A1</span> =&gt; <span class="keyword">B1 </span> &lt;:  <span class="built_in">A2</span> =&gt; <span class="keyword">B2</span></div></pre></td></tr></table></figure><blockquote><p>Functions are contravariant in their argument type(s) and covariant in their result type.</p></blockquote><h3 id="Variance-Checks"><a href="#Variance-Checks" class="headerlink" title="Variance Checks"></a>Variance Checks</h3><p>위에서 Array는 mutable한 속성 때문에 covariant하지 못하다는 문제를 살펴봤었다. mutable한 속성이라는 것은 update 가능하다는 말과 같은데, Array 클래스에서 update 함수의 파라미터의 타입이 어떤 문제를 가지고 있는지 살펴보자. 앞서서 covariant 타입은 함수의 result 타입에만 나타날 수 있다고 말했다.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>[+<span class="title">T</span>] &#123;</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(<span class="symbol">x:</span> T)</span></span> ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>그런데 위의 Array 클래스의 update 함수를 보면, covariant 타입 T가 파라미터에 쓰여졌기 때문에 Array는 covariant 하지 못<br>한 컨테이너라 할 수 있겠다.</p><p>그래서 앞서서 보았던(4.2) Function1은 사실 아래와 같은 형태이다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> scala</div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function1</span>[-<span class="title">T</span>, +<span class="title">U</span>] &#123;</span></div><div class="line">  <span class="keyword">def</span> apply(<span class="string">x:</span> T): U</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>그렇다면 List의 경우는 어떨까?<br>Nil, Cons 클래스의 경우로 살펴보자.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> week4</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">List</span>[+<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">T</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">List</span>[<span class="type">T</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cons</span>[<span class="type">T</span>](<span class="params">val head: <span class="type">T</span>, val tail: <span class="type">List</span>[<span class="type">T</span>]</span>) <span class="keyword">extends</span> <span class="title">List</span>[<span class="type">T</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span> </span>= <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Nil</span> <span class="keyword">extends</span> <span class="title">List</span>[<span class="type">Nothing</span>] </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">Nothing</span> = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span>(<span class="string">"Nil.head"</span>)</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">Nothing</span> = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span>(<span class="string">"Nil.tail"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// val x의 return 타입이 List[Nothing]을 상속받는 Nil object 이므로,</span></div><div class="line"><span class="comment">// covariant 규칙에 의해 List[String]으로 리턴 타입을 지정할 수 있다.</span></div><div class="line"><span class="comment">// List[Nothing] &lt;: List[String]</span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">test</span> </span>&#123;</div><div class="line">  <span class="keyword">val</span> x: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">Nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Nil이 List[Nothing]을 상속하게 만들면 모든 리스트의 서브타입이 된다. 그리고 trait List[T]를 trait List[+T]로 바꿔서 covariant하게 만들어 준다. val x: List[String] = Nil을 입력하게 되면, Nil이 List[Nothing]을 상속받으므로 covariant하게 바뀐 List 속성에 의해서 Nothing 보다 상위 클래스인 String 타입으로 리턴 할 수 있게 되었다.</p><p>List 클래스에 다음과 같은 prepend 메서드를 추가해보자.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> prepend(<span class="string">elem:</span> T): List[T] = <span class="keyword">new</span> Cons(eleml, <span class="keyword">this</span>)</div></pre></td></tr></table></figure><p>컴파일 에러가 난다. 그 이유는 타입 T가 covariant하기 때문에 파라미터에 사용하면 안된다. prepend 메서드가 새로운 리스트를 생성함해도 불구하고 문제가 생기는 이유는 prepend 메서드에 elem의 타입이 T이기 때문이다. 타입 T가 covariant하다면 반드시 result type에만 사용해야 한다.</p><h3 id="Prepend-Violates-LSP"><a href="#Prepend-Violates-LSP" class="headerlink" title="Prepend Violates LSP"></a>Prepend Violates LSP</h3><p>prepend 메서드가 왜 Liskov Substitution Principle을 위반했는지 알아보자<br>xs의 타입이 List[IntSet]인 경우에는 문제가 없다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">xs</span><span class="selector-class">.prepend</span>(<span class="selector-tag">Empty</span>)</div></pre></td></tr></table></figure><p>하지만 ys의 타입이 List[NonEmpty]라고 했을 때는 문제가 있다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ys</span><span class="selector-class">.prepend</span>(<span class="selector-tag">Empty</span>)</div></pre></td></tr></table></figure><p>NonEmpty 타입이 들어와야 할 자리에 Empty 타입이 들어왔으므로 타입에러가 발생한다. 그래서 이 경우에는 List[NonEmpty]는 List[IntSet]의 서브타입이 될 수 없다.</p><p>하지만 prepend 메서드는 immutable list에 실제로 존재한다. 어떻게 이게 가능할까? 답은 lower bound에 있다. U &gt;: T는 U가 T의 부모 타입이라는 말이다. 이렇게 되면, elem이 T보다 상위 타입이 오더라도 문제가 되지 않는다.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">def prepend[<span class="string">U &gt;: T</span>](<span class="link">elem: U</span>): List[U] = new Cons(elem, list)</div></pre></td></tr></table></figure><h2 id="4-5-Decomposition"><a href="#4-5-Decomposition" class="headerlink" title="4.5 Decomposition"></a>4.5 Decomposition</h2><p>다음과 같은 class 구조가 있다고 하자</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Expr</span> </span>&#123;</div><div class="line">  <span class="comment">// classification</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span></span>: <span class="type">Boolean</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isSum</span></span>: <span class="type">Boolean</span></div><div class="line">  <span class="comment">// accessor</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numValue</span></span>: <span class="type">Int</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">leftOp</span></span>: <span class="type">Expr</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">rightOp</span></span>: <span class="type">Expr</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span>(<span class="params">n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isSum</span></span>: <span class="type">Boolean</span> = <span class="literal">false</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numValue</span></span>: <span class="type">Int</span> = n</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">leftOp</span></span>: <span class="type">Expr</span> = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Error</span>(<span class="string">"Number.leftOp"</span>)</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">rightOp</span></span>: <span class="type">Expr</span> = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Error</span>(<span class="string">"Number.rightOp"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span>(<span class="params">e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span></span>: <span class="type">Boolean</span> = <span class="literal">false</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isSum</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numValue</span></span>: <span class="type">Int</span> = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Error</span>(<span class="string">"Sum.numValue"</span>)</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">rightOp</span></span>: <span class="type">Expr</span> = e1</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">leftOp</span></span>: <span class="type">Expr</span> = e2</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>무척 쓸모 없어 보이는 메서드들이 여럿 보인다. 일단은 더 나은 코드를 설명하기 위한 단계이므로 참고 살펴보자.<br>그리고 위의 클래스 구조를 evaluation하는 간단한 인터프리터 함수인 eval이 다음과 같다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def <span class="built_in">eval</span>(e: Expr): Int = &#123;</div><div class="line">  <span class="keyword">if</span> (e.isNumber) e.numValue</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (e.isSum) <span class="built_in">eval</span>(e.leftOp) + <span class="built_in">eval</span>(e.rightOp)</div><div class="line">  <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Unknown expression "</span> + e)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>이때 다음과 같은 코드가 있다면, 우선 eval 함수가 실행되면서 e가 어떤 타입인지 찾기 위해 classification method인 isSum으로 Sum 타입인지 찾을 것이다. 그리고 그 안의 두 인자가 각각 Number 이므로 또다시 eval 함수 내에서 isNumber에 의해 Number 타입인지 찾을 수 있을 것이다. 뭔가 비효율적으로 보인다.</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eval(<span class="name">Sum</span>(<span class="name">Number</span>(<span class="number">1</span>), Number(<span class="number">2</span>))) = <span class="number">3</span></div></pre></td></tr></table></figure><p>여기서 만약에 아래와 같은 두개의 클래스가 추가 된다면 어떨까?</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prod</span>(<span class="params">e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span>   <span class="title">//</span> <span class="title">e1</span> <span class="title">*</span> <span class="title">e2</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Var</span>(<span class="params">x: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span>         <span class="title">//</span> <span class="title">Variable</span> '<span class="title">x</span>'</span></div></pre></td></tr></table></figure><p>위의 두 클래스는 Number나 Sum과 마찬가지로 Expr을 상속받으므로 trait Expr의 메서드를 모두 구현해야한다. 그리고 isNum, isSum 과 같은 클래스 타입을 찾기 위한 메서드를 2개(isVar, isProd)더 추가해야 할 것이다. 또 var 값을 가져오기 위한 name 메서드도 추가되서 총 3개가 추가된다. 위의 구조에서만 15개의 메서드가 있는데, 단 2개의 클래스만 추가하더라도 더 필요한 메서드가 25개(Expr에 3개, Number에 3개, Sum에 3개, 그리고 새로운 클래스에 각각 8개)나 된다. 이건좀 아닌거 같다.</p><p>메서드를 좀 줄여보자<br>자바에서 사용하는 type test, type cast 메서드를 이용한다.</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Scala           Java</div><div class="line">x.isInstanceOf[<span class="built_in">T</span>]     x instanceof <span class="built_in">T</span>    // <span class="built_in">type</span> test</div><div class="line">x.asInstanceOf[<span class="built_in">T</span>]     (<span class="built_in">T</span>) x       // <span class="built_in">type</span> cast</div></pre></td></tr></table></figure><p>평가함수인 eval을 조금 고쳐보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def <span class="built_in">eval</span>(e: Expr): Int = &#123;</div><div class="line">  <span class="keyword">if</span> (e.isInstanceOf[<span class="built_in">Number</span>])</div><div class="line">    e.asInstanceOf[<span class="built_in">Number</span>].numValue</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (e.isInstanceOf[Sum])</div><div class="line">    <span class="built_in">eval</span>(e.asInstanceOf[Sum].leftOp) + <span class="built_in">eval</span>(e.asInstanceOf[Sum].rightOp)</div><div class="line">  <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Unknown expression "</span> + e)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>자바에서 사용하는 타입 test 함수인 instanceof와 타입 캐스팅 하는 방법을 적용하였다. 스칼라에서는 각각의 방법을 함수로 만들어 두었다. 이 방법을 사용하면 위에서 보았던 classification 메서드(isNum, inSum)를 사용할 필요가 없다. 대신에 타입 체크 및 캐스팅 함수가 low-level 함수이기 때문에 불안정한다는 단점이 있다.</p><p>Object-Oriented Decomposition을 이용한 또다른 해법을 살펴보자</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Expr</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>: <span class="type">Int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span>(<span class="params">n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>: <span class="type">Int</span> = n</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span>(<span class="params">e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>: <span class="type">Int</span> = e1.eval + e2.eval</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>각각의 클래스에 eval 함수를 구현하였다. 각 클래스에 맞게 구현되기 때문에 accessor 함수들도 불필요하다. 이제 많이 깔끔해졌다. 하지만 문제는 여전히 있다. rait에 하나의 메서드가 추가된다면, 나머지 클래스에 모두 구현해야한다는 점이다. 또다른 문제가 있다.</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">a</span> * b + <span class="keyword">a</span> * c = <span class="keyword">a</span> * (b + <span class="number">3</span>)</div></pre></td></tr></table></figure><p>위와 같이 축약하기 어렵다. 왜냐하면 이것은 non-local simplification이기 때문이다. 이것은 single object의 메서드로 캡슐화 할 수 없다. sub-tree를 모두 테스트하고 접근해야하는 문제가 있다.</p><h2 id="4-6-Pattern-Matching"><a href="#4-6-Pattern-Matching" class="headerlink" title="4.6 Pattern Matching"></a>4.6 Pattern Matching</h2><p>이전챕터에서 Decomposition을 시도한 몇가지 방법은 아래와 같다.</p><ul><li>Classification and access methods: quadratic explosion</li><li>Type tests and casts: unsafe, low-level</li><li>Object-oriented decomposition: does not always work, need to touch all classes to add a new method.</li></ul><p>classification과 accessor 의 주 목적은 아래와 같다.</p><ul><li>Which subclass was used?</li><li>What were the arguments of the constructor?</li></ul><p>보통 사용되는 new Sum(e1, e2)와 같은 형태의 생성자를 스칼라는 case class라는 문법을 통해서 자동으로 Pattern Matching 시켜준다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 두개의 case class</span></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Expr</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span>(<span class="params">n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span>(<span class="params">e1: </span></span></div><div class="line"><span class="type">Expr</span>, e2: <span class="type">Expr</span>) <span class="keyword">extends</span> <span class="title">Expr</span></div><div class="line"></div><div class="line"><span class="comment">// 실제 apply 메서드의 형태</span></div><div class="line"><span class="comment">// Number(1), Sum(2, 3)과 같이 호출될꺼다</span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Number</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(n: <span class="type">Int</span>) = <span class="keyword">new</span> <span class="type">Number</span>(n)</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Sum</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span>) = <span class="keyword">new</span> <span class="type">Sum</span>(e1, e2)</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="comment">// eval 함수를 이용해서 패턴매칭, </span></div><div class="line"><span class="comment">// 파라미터 e가 Number냐 Sum이냐에 따라서 자동으로 선택되어 처리</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>(e: <span class="type">Expr</span>): <span class="type">Int</span> = e <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">Number</span>(n) =&gt; n</div><div class="line">  <span class="keyword">case</span> <span class="type">Sum</span>(e1, e2) =&gt; eval(e1) + eval(e2)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Match-Syntax-rules"><a href="#Match-Syntax-rules" class="headerlink" title="Match Syntax rules"></a>Match Syntax rules</h3><ul><li>match is followed by a sequence of cases, pat =&gt; expr.</li><li>Each case associates an expression expr with a pattern pat.</li><li>A matchError exception is thrown if no pattern matches the value of the selector.</li></ul><p>패턴은 Number, Sum과 같은 contructor로 만들어지며, 인자(variables)는 반드시 소문자로 시작해야한다. 그리고 한 pattern 안에 같은 파라미터 문자를 쓰면 안된다. 상수는 null, true, false를 제외하고는 반드시 대문자로 시작해야한다. 마지막으로 wildcard pattern인 ‘<em>‘은 해당 파라미터를 신경쓰지 않겠다는 것이다. 대체로 해당 case에서 사용되지 않는 파라미터에 ‘</em>‘를 사용한다.</p><p>eval 함수를 trait Expr에 넣어보자.</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">trait</span> Expr &#123;</div><div class="line">  def <span class="keyword">eval</span>: <span class="keyword">Int</span> = this match &#123;</div><div class="line">    <span class="keyword">case</span> Number(n) =&gt; n</div><div class="line">    <span class="keyword">case</span> Sum(e1, e2) =&gt; e1.<span class="keyword">eval</span> + e2.<span class="keyword">eval</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-7-Lists"><a href="#4-7-Lists" class="headerlink" title="4.7 Lists"></a>4.7 Lists</h2><p>가장 기본적인 리스트 형태는 아래와 같이 정의할 수 있다.</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// List(X1, ..., Xn)</span></div><div class="line">val fruit: <span class="keyword">List</span>[String] = <span class="keyword">List</span>(<span class="string">"Apples"</span>, <span class="string">"oranges"</span>, <span class="string">"pears"</span>)</div><div class="line">val nums: <span class="keyword">List</span>[<span class="keyword">Int</span>] = <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line">val diag3: <span class="keyword">List</span>[<span class="keyword">List</span>[<span class="keyword">Int</span>]] = <span class="keyword">List</span>(<span class="keyword">List</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="keyword">List</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="keyword">List</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>))</div><div class="line">val <span class="keyword">empty</span>: <span class="keyword">List</span>[Nothing] = <span class="keyword">List</span>()</div></pre></td></tr></table></figure><p>스칼라에서 List와 Array는 중요한 두가지 차이가 있다.</p><ul><li>List are immutable - the elements of a list cannot be changed</li><li>Lists are recursive, while arrays are flat</li></ul><p>또한 스칼라에서는 construction operation인 ::(cons라 부름, 지난주의 prepend 함수랑 동일하다)를 이용하여 좀더 간단하게 리스트를 만들 수 있다. cons는 right-associative 연산이기 때문에 우측에서부터 왼쪽으로 하나씩 붙여 나간다는 생각으로 사용하면 된다. 위의 리스트 들을 cons를 이용해서 작성해보면 다음과 같다.</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fruit = <span class="string">"apples"</span> :: (<span class="string">"oranges"</span> :: (<span class="string">"pears"</span> :: Nil))</div><div class="line">fruit = <span class="string">"apples"</span> :: <span class="string">"oranges"</span> :: <span class="string">"pears"</span> :: Nil</div><div class="line"></div><div class="line">nums = <span class="number">1</span> :: (<span class="number">2</span> :: (<span class="number">3</span> :: (<span class="number">4</span> :: Nil)))</div><div class="line">nums = <span class="number">1</span> :: <span class="number">2</span> :: <span class="number">3</span> :: <span class="number">4</span> :: Nil</div><div class="line"></div><div class="line">empty = Nil</div></pre></td></tr></table></figure><p>right-associative 연산이기 때문에 실제 컴파일러는 위의 연산(nums)을 다음과 같이 해석한다.</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nums = <span class="number">1</span> :: <span class="number">2</span> :: <span class="number">3</span> :: <span class="number">4</span> :: Nil</div><div class="line">Nils.::(<span class="number">4</span>).::(<span class="number">3</span>).::(<span class="number">2</span>).::(<span class="number">1</span>)</div></pre></td></tr></table></figure><h3 id="sorting-Lists"><a href="#sorting-Lists" class="headerlink" title="sorting Lists"></a>sorting Lists</h3><p>재귀를 이용한 Insertion Sort</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">def isort(xs: <span class="keyword">List</span>[<span class="keyword">Int</span>]): <span class="keyword">List</span>[<span class="keyword">Int</span>] = &#123;</div><div class="line">  xs match &#123;</div><div class="line">    <span class="keyword">case</span> Nil =&gt; <span class="keyword">List</span>()</div><div class="line">    <span class="keyword">case</span> y :: ys =&gt; insert(y, isort(ys))</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">def insert(x: <span class="keyword">Int</span>, xs: <span class="keyword">List</span>[<span class="keyword">Int</span>]): <span class="keyword">List</span>[<span class="keyword">Int</span>] = &#123;</div><div class="line">  xs match &#123;</div><div class="line">    <span class="keyword">case</span> Nil =&gt; <span class="keyword">List</span>(x)</div><div class="line">    <span class="keyword">case</span> y :: ys =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (x &lt; y)  x :: xs</div><div class="line">      <span class="keyword">else</span> y :: insert(x, ys)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><ul class="pager"><li class="previous"><a href="/2016/07/26/2016-07-26-functional-programming-in-scala-week5/" data-toggle="tooltip" data-placement="top" title="Functional Programming in Scala week 5">&larr; Previous Post</a></li><li class="next"><a href="/2016/07/26/2016-07-26-functional-programming-in-scala-week3/" data-toggle="tooltip" data-placement="top" title="Functional Programming in Scala week 3">Next Post &rarr;</a></li></ul><div class="comment"><div id="disqus_thread" class="disqus-thread"></div></div></div><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 sidebar-container"><section><h5><a href="/tags/">FEATURED TAGS</a></h5><div class="tags"><a class="tag" href="/tags/#scala" title="scala">scala</a> <a class="tag" href="/tags/#coursera" title="coursera">coursera</a></div></section></div></div></div></article><script type="text/javascript">var disqus_shortname="bonogithub",disqus_identifier="http://blueshw.githup.io/2016/07/26/2016-07-26-functional-programming-in-scala-week4/",disqus_url="http://blueshw.githup.io/2016/07/26/2016-07-26-functional-programming-in-scala-week4/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script>function async(e,n){var t=document,a="script",r=t.createElement(a),c=t.getElementsByTagName(a)[0];r.src=e,n&&r.addEventListener("load",function(e){n(null,e)},!1),c.parentNode.insertBefore(r,c)}</script><script>async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){anchors.options={visible:"always",placement:"right",icon:"#"},anchors.add().remove(".intro-header h1").remove(".subheading").remove(".sidebar-container h5")})</script><style>@media all and (min-width:800px){.anchorjs-link{position:absolute;left:-.75em;font-size:1.1em;margin-top:-.1em}}</style><footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a target="_blank" href="https://www.facebook.com/blueshw"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-facebook fa-stack-1x fa-inverse"></i></span></a></li><li><a target="_blank" href="https://github.com/blueshw"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 보노의 블로그 2017<br>Theme by <a href="http://huangxuan.me">Hux</a> <span style="display:inline-block;margin:0 5px"><i class="fa fa-heart"></i> </span>Ported by <a href="http://blog.kaijun.rocks">Kaijun</a> |<iframe style="margin-left:2px;margin-bottom:-5px" frameborder="0" scrolling="0" width="91px" height="20px" src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true"></iframe></p></div></div></div></footer><script src="/js/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/hux-blog.min.js"></script><script>function async(e,n){var t=document,a="script",r=t.createElement(a),c=t.getElementsByTagName(a)[0];r.src=e,n&&r.addEventListener("load",function(e){n(null,e)},!1),c.parentNode.insertBefore(r,c)}</script><script>0!==$("#tag_cloud").length&&async("http://blueshw.githup.io/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js",function(){var c=document.querySelector("nav");c&&FastClick.attach(c)})</script><script>var _gaId="UA-50048807-2",_gaDomain="blueshw.github.io";!function(e,a,n,t,g,o,c){e.GoogleAnalyticsObject=g,e[g]=e[g]||function(){(e[g].q=e[g].q||[]).push(arguments)},e[g].l=1*new Date,o=a.createElement(n),c=a.getElementsByTagName(n)[0],o.async=1,o.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(o,c)}(window,document,"script",0,"ga"),ga("create",_gaId,_gaDomain),ga("send","pageview")</script><img src="http://blueshw.githup.io/img/icon_wechat.png" width="0" height="0"></body></html>