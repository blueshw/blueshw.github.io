<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content=""><meta name="keyword" content=""><link rel="shortcut icon" href="/img/favicon.ico"><title>Functional Programming in Scala week 5 - 보노의블로그 | Bono&#39;s Blog</title><link rel="canonical" href="http://blueshw.githup.io/2016/07/26/2016-07-26-functional-programming-in-scala-week5/"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/hux-blog.css"><link rel="stylesheet" href="/css/highlight.css"><link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]--><script></script></head><body ontouchstart=""><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class="container-fluid"><div class="navbar-header page-scroll"><button type="button" class="navbar-toggle"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand" href="/">보노의 블로그</a></div><div id="huxblog_navbar"><div class="navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="/">Home</a></li><li><a href="/about/">About</a></li><li><a href="/archives/">Archives</a></li><li><a href="/tags/">Tags</a></li></ul></div></div></div></nav><script>function handleMagic(e){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic)</script><style type="text/css">header.intro-header{background-image:url(/img/home-bg.jpg)}</style><header class="intro-header"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-heading"><div class="tags"><a class="tag" href="/tags/#scala" title="scala">scala</a> <a class="tag" href="/tags/#coursera" title="coursera">coursera</a></div><h1>Functional Programming in Scala week 5</h1><h2 class="subheading"></h2><span class="meta">Posted by bono on 2016-07-26</span></div></div></div></div></header><article><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container"><h2 id="5-1-More-Functions-on-Lists"><a href="#5-1-More-Functions-on-Lists" class="headerlink" title="5.1 More Functions on Lists"></a>5.1 More Functions on Lists</h2><p>이번 챕터에서는 스칼라 List의 다른 메서드 들을 알아본다.<br>xs는 list의 object를 뜻한다.</p><h3 id="Sublists-and-element-access"><a href="#Sublists-and-element-access" class="headerlink" title="Sublists and element access"></a>Sublists and element access</h3><ul><li>xs.length xs의 길이</li><li>xs.last xs의 마지막 item return, xs가 비어있으면 exception 발생</li><li>xs.init 마지막 item을 제외한 list reutnr, xs가 비어있으면 exception 발생</li><li>xs take n 처음부터 n개의 element의 list 리턴, n이 xs의 length보다 크면 n개만 리턴</li><li>xs drop n n개를 제외한 나머지 리스트 리턴</li><li>xs(n) n번째 item 리턴</li></ul><h3 id="Creating-new-lists"><a href="#Creating-new-lists" class="headerlink" title="Creating new lists"></a>Creating new lists</h3><ul><li>xs ++ ys 두 list 더하기, :::와 같은 기능을 함</li><li>xs.reverse 역순의 리스트 생성</li><li>xs updated (n, x) n번째 item만 x로 바뀐 list 생성</li></ul><h3 id="Finding-elements"><a href="#Finding-elements" class="headerlink" title="Finding elements"></a>Finding elements</h3><ul><li>xs indexOf x x와 같은 첫번째 element의 index 값 리턴, 없으면 -1</li><li>xs contains x indexOf x &gt;= 0 과 같음</li></ul><p>last가 과연 필요한지 모르겠지만(tail을 recursive하게 반복하면 찾을 수 있음), 유용하게 쓰일 수 있다면 last의 복잡도는 어떻게 될까?</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def last[T](xs: <span class="built_in">List</span>[T]): T = xs match &#123;</div><div class="line">  <span class="keyword">case</span> <span class="built_in">List</span>() =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"last of empty list"</span>)</div><div class="line">  <span class="keyword">case</span> <span class="built_in">List</span>(x) =&gt; x</div><div class="line">  <span class="keyword">case</span> y :: ys =&gt; lsat(ys)  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>위와 같이 list의 길이와 같으므로, 복잡도는 O(n)이 되겠다.<br>init 메서드는 어떨까?</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def init[T](xs: <span class="built_in">List</span>[T]): <span class="built_in">List</span>[T] = xs match &#123;</div><div class="line">  <span class="keyword">case</span> <span class="built_in">List</span>() =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"init of empty list"</span>)</div><div class="line">  <span class="keyword">case</span> <span class="built_in">List</span>(x) =&gt; <span class="built_in">List</span>()</div><div class="line">  <span class="keyword">case</span> y :: ys =&gt; y :: init(ys)   </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>마찬가지로 O(n)<br>그다음은 concat(Same as :::)</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def concat[<span class="string">T</span>](<span class="link">xs: List[T], ys: List[T]</span>) = xs match &#123;</div><div class="line">  case List() =&gt; ys</div><div class="line">  case z :: zs =&gt; z :: concat(zs, ys) </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>복잡도는 |xs|, 즉 xs 의 길이가 된다.<br>다음은 reverse</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def reverse[<span class="string">T</span>](<span class="link">xs: List[T]</span>): List[T] = xs match &#123;</div><div class="line">  case List() =&gt; xs</div><div class="line">  case y :: ys =&gt; reverse(ys) ++ List(y)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>reverse(ys) :: y 가 아니라 reverse(ys) ++ List(y)인 이유는 ::의 마지막엔 Nil이 와야하니깐 y가 Nil이 아니기 때문이 아닐까 생각한다.<br>복잡도는 각 요소마다 concatenating을 해주고 list의 length만큼 reverse를 해야하므로 O(n2)이 되겠다. reverse는 다소 실망스러운 성능을 보여주는데, 앞으로 더 개선해보도록 하겠다.</p><p>마지막으로 removeAt</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">def removeAt[<span class="string">T</span>](<span class="link">n: Int, xs: List[T]</span>) = (xs take n) ::: (xs drop n+1)</div></pre></td></tr></table></figure><h2 id="5-2-Paires-and-Tuples"><a href="#5-2-Paires-and-Tuples" class="headerlink" title="5.2 Paires and Tuples"></a>5.2 Paires and Tuples</h2><p>앞서 살펴보앗던 insertion sort보다 더 개선된 merge sort 알고리즘에 대해서 살펴보자. 기본적인 개념은 zero or one element 리스트는 이미 sorted 하다는 것.</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">def msort(xs: <span class="keyword">List</span>[<span class="keyword">Int</span>]): <span class="keyword">List</span>[<span class="keyword">Int</span>] = &#123;</div><div class="line">  val n = xs.length/<span class="number">2</span></div><div class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) xs</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// merge 메서드는 앞으로 더 개선해 나갈 예정임</span></div><div class="line">    def merge(xs: <span class="keyword">List</span>[<span class="keyword">Int</span>], ys: <span class="keyword">List</span>[<span class="keyword">Int</span>]) = </div><div class="line">      xs mathch &#123;</div><div class="line">        <span class="keyword">case</span> Nil =&gt; ys</div><div class="line">        <span class="keyword">case</span> x :: xs1 =&gt;</div><div class="line">          ys match &#123;</div><div class="line">            <span class="keyword">case</span> Nil =&gt; xs</div><div class="line">            <span class="keyword">case</span> y :: ys1 =&gt;</div><div class="line">              <span class="keyword">if</span> (x &lt; y) x :: merge(xs1, ys)</div><div class="line">              <span class="keyword">else</span> y :: merge(xs, ys1)</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    val (fst, snd) = xs splitAt n</div><div class="line">    merge(msort(fst), msort(snd))</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>밑에서 나오는 splitAt 함수는 index n을 기준으로 리스트를 두개로 쪼개서 리턴한다. 여기서 리턴된 val의 모양을 보자. fst와 snd 두개의 타입으로 묶여져 있다. 이를 Pair라고 한다. 예를 들면</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val pair = (<span class="string">"answer"</span>, <span class="number">42</span>) &gt; pair: (<span class="built_in">String</span>, <span class="built_in">Int</span>) = (answer,<span class="number">42</span>)  </div><div class="line"></div><div class="line">val (label, value) = pare &gt; label: <span class="built_in">String</span> = answer | value : <span class="built_in">Int</span> = <span class="number">42</span></div></pre></td></tr></table></figure><p>위와 같이 타입으로도 쓰일 수 있고, 패턴으로도 사용될 수 있다. 이때 2개 이상의 요소를 가지면 Tuples라 한다. Tuples는 다양하게 사용될 수 있는데, parameterized type으로 사용될 경우, function applictaion으로 사용될 경우, constructor 패턴으로 사용될 경우 각각</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">scala</span><span class="selector-class">.Tuplen</span><span class="selector-attr">[T1, ..., Tn]</span></div><div class="line"><span class="selector-tag">scala</span><span class="selector-class">.Tuplen</span>(<span class="selector-tag">e1</span>, ..., <span class="selector-tag">en</span>)</div><div class="line"><span class="selector-tag">scala</span><span class="selector-class">.Tuplen</span>(<span class="selector-tag">p1</span>, ..., <span class="selector-tag">pn</span>)</div></pre></td></tr></table></figure><p>과 같이 사용할 수 있다. (여기서 Tuplen의 n은 파라미터 개수 ex. Tuple2)<br>튜플의 각 element는 _1, _2와 같이 접근할 수 있다.<br>이제 merge 메소드를 개선해보자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def <span class="keyword">merge</span>(xs: <span class="keyword">List</span>[<span class="built_in">Int</span>], ys: <span class="keyword">List</span>[<span class="built_in">Int</span>]): <span class="keyword">List</span>[<span class="built_in">Int</span>] = (xs, ys) <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> (Nil, ys) =&gt; ys</div><div class="line">  <span class="keyword">case</span> (xs, Nil) =&gt; xs</div><div class="line">  <span class="keyword">case</span> (x :: xs1, y :: ys1) =&gt; </div><div class="line">    <span class="keyword">if</span> (x &lt; y) x :: <span class="keyword">merge</span>(xs1, ys)</div><div class="line">    <span class="keyword">else</span> y :: <span class="keyword">merge</span>(xs, ys1)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>훨씬 깔끔해졌다.</p><h2 id="5-3-Implicit-Parameters"><a href="#5-3-Implicit-Parameters" class="headerlink" title="5.3 Implicit Parameters"></a>5.3 Implicit Parameters</h2><p>이전 장에서 보았던 msort는 List[Int] 타입으로 지정되어 있는데 parameterize를 통해서 Int 말고도 다른 타입이 들어올 수 있도록 임의의 타입 T로 변경해보자</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">mergesort</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">msort</span></span>[<span class="type">T</span>](xs: <span class="type">List</span>[<span class="type">T</span>]): <span class="type">List</span>[<span class="type">T</span>] = &#123;</div><div class="line">    <span class="keyword">val</span> n = xs.length/<span class="number">2</span></div><div class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) xs</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(xs: <span class="type">List</span>[<span class="type">T</span>], ys: <span class="type">List</span>[<span class="type">T</span>]): <span class="type">List</span>[<span class="type">T</span>] = (xs, ys) <span class="keyword">match</span> &#123;</div><div class="line">        <span class="keyword">case</span> (<span class="type">Nil</span>, ys) =&gt; ys</div><div class="line">        <span class="keyword">case</span> (xs, <span class="type">Nil</span>) =&gt; xs</div><div class="line">        <span class="keyword">case</span> (x :: xs1, y :: ys1) =&gt;</div><div class="line">          <span class="keyword">if</span> (x &lt; y) x :: merge(xs1, ys)</div><div class="line">          <span class="keyword">else</span> y :: merge(xs, ys1)</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">val</span> (fst, snd) = xs splitAt n</div><div class="line">      merge(msort(fst), msort(snd))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">val</span> nums = <span class="type">List</span>(<span class="number">2</span>, <span class="number">-4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>)</div><div class="line">  msort(nums)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>x &lt; y 부분에서 에러가 발생한다. 왜냐하면 comparison ‘&lt;’가 임의의 타입 T에 정의되어 있지 않기 때문이란다….<br>그래서 우리는 comparison 함수가 필요하다. 이 때 가장 유연한 방법은 msort 함수에 comparison operation을 추가적인 파라미터로 붙이는 것이다. 아래처럼</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def msort[<span class="string">T</span>](<span class="link">xs: List[T]</span>)(lt: (T, T) =&gt; Boolean) = &#123;</div><div class="line">  ...</div><div class="line">  merge(msort(fst)(lt), msort(snd)(lt))</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>그래서 원래 mergesort에 적용하면 다음과 같다.</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">object mergesort &#123;</div><div class="line">  def msort[T](xs: <span class="keyword">List</span>[T])(lt: (T, T) =&gt; <span class="keyword">Boolean</span>): <span class="keyword">List</span>[T] = &#123;</div><div class="line">    val n = xs.length/<span class="number">2</span></div><div class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) xs</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      def merge(xs: <span class="keyword">List</span>[T], ys: <span class="keyword">List</span>[T]): <span class="keyword">List</span>[T] = (xs, ys) match &#123;</div><div class="line">        <span class="keyword">case</span> (Nil, ys) =&gt; ys</div><div class="line">        <span class="keyword">case</span> (xs, Nil) =&gt; xs</div><div class="line">        <span class="keyword">case</span> (x :: xs1, y :: ys1) =&gt;</div><div class="line">          <span class="keyword">if</span> (lt(x, y)) x :: merge(xs1, ys)</div><div class="line">          <span class="keyword">else</span> y :: merge(xs, ys1)</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      val (fst, snd) = xs splitAt n</div><div class="line">      merge(msort(fst)(lt), msort(snd)(lt))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  val nums = <span class="keyword">List</span>(<span class="number">2</span>, <span class="number">-4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>)</div><div class="line">  msort(nums)((x, y) =&gt; x &lt; y)</div><div class="line"></div><div class="line">  val fruits = <span class="keyword">List</span>(<span class="string">"apple"</span>, <span class="string">"pineapple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>)</div><div class="line">  msort(fruits)((x, y) =&gt; x.compareTo(y) &lt; <span class="number">0</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>이제 Int 타입 뿐만 아니라 String과 같은 다른 타입도 정렬이 가능해졌다. 이 때 lt에 들어오는 함수 파라미터에 타입 붙이는 걸 생략해도 되는데, 컴파일러가 앞에 있는 리스트의 타입을 보고 유추할 수 있기 때문이란다. 즉 파라미터 셋의 마지막에 function value가 들어오게 되면, 컴파일러가 타입 체크를 미뤄버린다.</p><h3 id="scala-math-Ordering-T"><a href="#scala-math-Ordering-T" class="headerlink" title="scala.math.Ordering[T]"></a>scala.math.Ordering[T]</h3><p>사실 ordering을 위한 스탠다드 라이브러리 클래스가 있다.</p><blockquote><p>scala.math.Ordering[T]</p></blockquote><p>그래서 lt 명령어를 parameterizing 하는 대신 Orderging 클래스로 parameterize 할 수 있다.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def msort[<span class="string">T</span>](<span class="link">xs: List[T]</span>)(ord: Ordering) = </div><div class="line"></div><div class="line">  def merge(xs: List[T], ys: List[T]) =</div><div class="line"><span class="code">    ... if (ord.lt(x, y)) ...</span></div><div class="line"></div><div class="line">  ... merge(msort(fst)(ord), msort(snd)(ord)) ...</div></pre></td></tr></table></figure><h3 id="implicit"><a href="#implicit" class="headerlink" title="implicit"></a>implicit</h3><p>대체로 완성된 느낌이 나지만, Ordering 함수가 처음 콜 될때부터 계속 전달되는게 좀 비효율적으로 보인다. 그래서 여기에다가 또하나를 추가해보자.<br>ord 파라미터에 implicit(절대적인이란 뜻) 키워드를 앞에 붙여보자. 그러면, 함수를 실제로 호출하는 부분에서 실제 파라미터를 넣어줄 필요가 없다.</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def msort[T](xs: List[T])(<span class="keyword">implicit</span> ord: Ordering) = </div><div class="line"></div><div class="line">  def <span class="built_in">merge</span>(xs: List[T], ys: List[T]) =</div><div class="line">    ... <span class="keyword">if</span> (ord.lt(x, y)) ...</div><div class="line"></div><div class="line">  ... <span class="built_in">merge</span>(msort(fst), msort(snd)) ...</div><div class="line"></div><div class="line">val nums = List(<span class="number">2</span>, -<span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>)</div><div class="line">msort(nums)</div></pre></td></tr></table></figure><p>더 간결해졌다.</p><h3 id="Rules-for-Implicit-Parameters"><a href="#Rules-for-Implicit-Parameters" class="headerlink" title="Rules for Implicit Parameters"></a>Rules for Implicit Parameters</h3><p>타입이 T인 implicit 파라미터가 있을때, 컴파일러는</p><blockquote><p>(1) implicit이 쓰인 파라미터에 (2) T와 호환되는 타입을 가지고 (3) function call에서 보이거나 T와 관련된 companion 오브젝트(클래스와 객체 이름이 같은 오브젝트)에서<br>single implicit definition을 찾는다. 즉, Ordering[Int]가 함수 call의 파라미터로 존재하지 않지만, implicit으로 처리되어 어딘가에 존재하게 된다.</p></blockquote><h2 id="5-4-Higher-Order-List-Functions"><a href="#5-4-Higher-Order-List-Functions" class="headerlink" title="5.4 Higher-Order List Functions"></a>5.4 Higher-Order List Functions</h2><p>위에서 보았던 예제들은 종종 비슷한 구조를 보여준다. 요약해보면</p><ul><li>리스트의 각 element를 변경하는 것</li><li>어떤 조건을 만족하는 모든 element의 리스트를 구하는 것</li><li>연산자를 사용하여 element들을 결합하는 것</li></ul><p>함수형 언어는 higer-order functinos 패턴을 이용하는 generic function을 만들 수 있다.</p><p>첫번째 예제는 각 요소를 multiply 하는 것이다.</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def scaleList(xs: <span class="keyword">List</span>[<span class="keyword">Double</span>], factor: <span class="keyword">Double</span>): <span class="keyword">List</span>[<span class="keyword">Double</span>] = xs match &#123;</div><div class="line">  <span class="keyword">case</span> Nil =&gt; xs</div><div class="line">  <span class="keyword">case</span> y :: ys =&gt; y * factor :: scaleList(ys, factor)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>위 예제는 list의 map 메서드를 이용하여 만들 수 있다.<br>map 메서드의 구조를 살펴보면 아래와 같다.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">abstract class List[T] &#123; ...</div><div class="line">  def map[<span class="string">U</span>](<span class="link">f: T =&gt; U</span>): List[U] = this match &#123;</div><div class="line"><span class="code">    case Nil =&gt; this</span></div><div class="line"><span class="code">    case x :: xs =&gt; f(x) :: xs.map(f)</span></div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>파라미터로 들어온 함수f가 각 element에 적용되어서 새로운 리스트를 만들어 내는 함수가 바로 map이다. map 메서드를 이용하면 훨씬 간단하게 작성할 수 있다</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def scaleList(xs: <span class="keyword">List</span>[<span class="keyword">Double</span>], factor: <span class="keyword">Double</span>) =</div><div class="line">  xs.map(x =&gt; x * factor)</div></pre></td></tr></table></figure><p>또하나의 예제를 살펴보자</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def squareList(xs: <span class="keyword">List</span>[<span class="keyword">Int</span>]): <span class="keyword">List</span>[<span class="keyword">Int</span>] = xs match &#123;</div><div class="line">  <span class="keyword">case</span> Nil =&gt; Nil</div><div class="line">  <span class="keyword">case</span> y :: ys =&gt; y * y :: squareList(ys)</div><div class="line">&#125;</div><div class="line"></div><div class="line">def squareList(xs: <span class="keyword">List</span>[<span class="keyword">Int</span>]): <span class="keyword">List</span>[<span class="keyword">Int</span>] =</div><div class="line">  xs map (y =&gt; y * y)</div></pre></td></tr></table></figure><h3 id="Filtering"><a href="#Filtering" class="headerlink" title="Filtering"></a>Filtering</h3><p>필터링은 어떤 조건에 맞는 element를 모아 새로운 리스트를 만들어 내는 메서드이다.<br>0보다 큰수만 필터링 하는 다음의 함수를 보자</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def posElems(xs: <span class="keyword">List</span>[<span class="keyword">Int</span>]): <span class="keyword">List</span>[<span class="keyword">Int</span>] = xs match &#123;</div><div class="line">  <span class="keyword">case</span> Nil =&gt; xs</div><div class="line">  <span class="keyword">case</span> y :: ys =&gt; <span class="keyword">if</span> (y &gt; <span class="number">0</span>) y :: posElems(ys) <span class="keyword">else</span> posElems(ys)  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>필터를 이용하면 간단하게 해결할 수 있다. 우선은 filter 메서드가 어떻게 생겼는지부터 살펴보도록 하자.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span>[<span class="title">T</span>] </span>&#123;</div><div class="line">  ...</div><div class="line">  def filter(p: T =&gt; Boolean): <span class="built_in">List</span>[T] = <span class="keyword">this</span> match &#123;</div><div class="line">    <span class="keyword">case</span> Nil =&gt; <span class="keyword">this</span></div><div class="line">    <span class="keyword">case</span> x :: xs =&gt; <span class="keyword">if</span> (p(x)) x :: xs.filter(p) <span class="keyword">else</span> xs.filter(p)</div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>필터는 특정조건함수(p)가 true이면 :: 연산자를 이용하여 리스트에 붙이고 false이면 제외하는 방식으로 새로운 리스트를 만들어간다.<br>그럼 위에서 보았던 posElems를 filter를 이용해 재구성해보자</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def posElems(xs: <span class="keyword">List</span>[<span class="keyword">Int</span>]): <span class="keyword">List</span>[<span class="keyword">Int</span>] = </div><div class="line">  xs filter(x =&gt; x &gt; <span class="number">0</span>)</div></pre></td></tr></table></figure><p>그외에 유용한 메서드 목록은 아래와 같다.</p><ul><li>xs filterNot p xs filter (x =&gt; !p(x))와 같다.</li><li>xs partition p (xs filter p, xs filterNot) 튜플</li><li>xs takeWhile p p를 만족하는 요소들의 가장 긴 리스트</li><li>xs dropWhile p p를 만족하는 요소들의 나머지</li><li>xs span p (xs takeWhile p, xs dropWhile p) 튜플</li></ul><p>예를 들어보자</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">scala&gt; val nums = <span class="keyword">List</span>(<span class="number">2</span>, <span class="number">-4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>)</div><div class="line">nums: <span class="keyword">List</span>[<span class="keyword">Int</span>] = <span class="keyword">List</span>(<span class="number">2</span>, <span class="number">-4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>)</div><div class="line"></div><div class="line">scala&gt; nums filter (x =&gt; x &gt; <span class="number">0</span>)</div><div class="line">res0: <span class="keyword">List</span>[<span class="keyword">Int</span>] = <span class="keyword">List</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>)</div><div class="line"></div><div class="line">scala&gt; nums filterNot (x =&gt; x &gt; <span class="number">0</span>)</div><div class="line">res1: <span class="keyword">List</span>[<span class="keyword">Int</span>] = <span class="keyword">List</span>(<span class="number">-4</span>)</div><div class="line"></div><div class="line">scala&gt; nums partition (x =&gt; x &gt; <span class="number">0</span>)</div><div class="line">res2: (<span class="keyword">List</span>[<span class="keyword">Int</span>], <span class="keyword">List</span>[<span class="keyword">Int</span>]) = (<span class="keyword">List</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>),<span class="keyword">List</span>(<span class="number">-4</span>))</div><div class="line"></div><div class="line">scala&gt; nums takeWhile (x =&gt; x &gt; <span class="number">0</span>)</div><div class="line">res3: <span class="keyword">List</span>[<span class="keyword">Int</span>] = <span class="keyword">List</span>(<span class="number">2</span>)</div><div class="line"></div><div class="line">scala&gt; nums dropWhile (x =&gt; x &gt; <span class="number">0</span>)</div><div class="line">res4: <span class="keyword">List</span>[<span class="keyword">Int</span>] = <span class="keyword">List</span>(<span class="number">-4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>)</div><div class="line"></div><div class="line">scala&gt; nums span (x =&gt; x &gt; <span class="number">0</span>)</div><div class="line">res5: (<span class="keyword">List</span>[<span class="keyword">Int</span>], <span class="keyword">List</span>[<span class="keyword">Int</span>]) = (<span class="keyword">List</span>(<span class="number">2</span>),<span class="keyword">List</span>(<span class="number">-4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>))</div></pre></td></tr></table></figure><h2 id="5-5-Reductino-of-Lists"><a href="#5-5-Reductino-of-Lists" class="headerlink" title="5.5 Reductino of Lists"></a>5.5 Reductino of Lists</h2><p>5.4절에 이어 higr-order Function 패턴을 이용한 List 메서드에 대해서 계속 알아보도록 하자. 5.4에서 보았던 세가지 패턴 중에 마지막인 element를 결합하는 방법들에 대한 내용들이 되겠다.</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sum</span>(<span class="built_in">List</span>(x1, <span class="params">...</span>, xn))      = <span class="number">0</span> + x1 + <span class="params">...</span> + xn</div><div class="line">product(<span class="built_in">List</span>(x1, <span class="params">...</span>, xn))  = <span class="number">1</span> * x1 * <span class="params">...</span> * xn</div></pre></td></tr></table></figure><h3 id="ReduceLeft"><a href="#ReduceLeft" class="headerlink" title="ReduceLeft"></a>ReduceLeft</h3><p>각 요소를 더하거나 곱하는 sum과 product 메서드가 있다. 이를 ReduceLeft 메서드를 이용하여 구현해보도록하자. ReduceLeft 메서드는 아래와 같은 구조를 가진다.</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">List(x1, ..., xn) reduceLeft <span class="built_in">op</span> = (...(x1 <span class="built_in">op</span> x2) <span class="built_in">op</span> ... ) <span class="built_in">op</span> xn</div><div class="line"></div><div class="line">// 위의 구조를 이용하면 <span class="built_in">sum</span>과 <span class="built_in">product</span>는 아래와 같이 구현가능하다.</div><div class="line">def <span class="built_in">sum</span>(xs: List[Int]) = (<span class="number">0</span> :: xs) reduceLeft ((x, y) =&gt; x + y) // <span class="keyword">or</span> (<span class="symbol">_</span> + <span class="symbol">_</span>)</div><div class="line">def <span class="built_in">product</span>(xs: List[Int]) = (<span class="number">1</span> :: xs) reduceLeft ((x, y) =&gt; x * y) // <span class="keyword">or</span> (<span class="symbol">_</span> * <span class="symbol">_</span>)</div></pre></td></tr></table></figure><h3 id="FoldLeft"><a href="#FoldLeft" class="headerlink" title="FoldLeft"></a>FoldLeft</h3><p>foldLeft 함수는 reduceLeft 함수에 비해 좀더 일반적인 형태이다. foldLeft가 reduceLeft와 비슷하지만, foldLeft는 하나의 accumulator(z)를 가진다.<br>구조는 아래와 같다.</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">List</span>(<span class="name">x1</span>, ..., xn) foldLeft z)(<span class="name">op</span>) = (...(<span class="name">z</span> op x1) op ...) op xn</div></pre></td></tr></table></figure><p>foldLeft로 sum과 product를 구현해보자</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def sum(<span class="name">xs</span>: List[Int]) = (<span class="name">xs</span> foldLeft <span class="number">0</span>) (<span class="name">_</span> + _)</div><div class="line">def product(<span class="name">xs</span>: List[Int]) = (<span class="name">xs</span> foldLeft <span class="number">1</span>) (<span class="name">_</span> * _)</div></pre></td></tr></table></figure><p>foldLeft와 reduceLeft는 List class에서 다음과 같이 구현된다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span>[<span class="title">T</span>] &#123;</span> ...</div><div class="line">  <span class="keyword">def</span> reduceLeft(<span class="string">op:</span> (T, T) =&gt; T): T = <span class="keyword">this</span> match &#123;</div><div class="line">    <span class="keyword">case</span> Nil =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Nil.reduceLeft"</span>)</div><div class="line">    <span class="keyword">case</span> <span class="string">x :</span>: xs =&gt; (xs foldLeft x)(op)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">def</span> foldLeft[U](<span class="string">z:</span> U)(<span class="string">op:</span> (U, T) =&gt; U): U = <span class="keyword">this</span> match &#123;</div><div class="line">    <span class="keyword">case</span> Nil =&gt; z</div><div class="line">    <span class="keyword">case</span> <span class="string">x :</span>: xs =&gt; (xs foldLeft op(z, x))(op)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>reduceLeft도 내부적으로는 foldLeft 메서드를 이용한다.<br>그리고 reduceRight와 foldRight도 위의 두 메서드와 비슷한 구조로 동작한다. 대신 좌측이 아닌 우측(뒤)부터 reduce한다.</p><h3 id="Difference-between-FoldLeft-and-FoldRight"><a href="#Difference-between-FoldLeft-and-FoldRight" class="headerlink" title="Difference between FoldLeft and FoldRight"></a>Difference between FoldLeft and FoldRight</h3><p>foldLeft와 foldRight는 무엇이 다를까? 기본적으로 sum을 가지고 생각했을때, 왼쪽부터 더하는 것이나 오른쪽부터 더하는 것이나 결과는 동일하다. 하지만 어떤 경우에는 둘 중 하나만 적절할 때도 있다. 아래의 예제를 보자</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">def concat[<span class="string">T</span>](<span class="link">xs: List[T], ys: List[T]</span>): List[T] = (xs foldRight ys) (<span class="emphasis">_ :: _</span>)</div></pre></td></tr></table></figure><p>위의 함수에서 foldRight를 foldLeft로 변경하면, 타입에러가 발생한다.<br>1 :: List(2)는 가능하지만 List(1) :: 2 는 불가능한 연산이기 때문이다.</p><h2 id="5-6-Reasoning-About-Concat"><a href="#5-6-Reasoning-About-Concat" class="headerlink" title="5.6 Reasoning About Concat"></a>5.6 Reasoning About Concat</h2><p>이번 챕터에서는 어떤 연산자(or 함수)가 정확히 참임을 증명할 수 있는지에 대해 알아보도록 한다.<br>일반적으로 natural induction(자연 귀납?)에 의해 증명하는 방법의 예는 다음과 같다.</p><ul><li>P(n)이 모든 n &gt;= b 에대해서</li><li>P(b)가 참이다. (base case)</li><li>이때, 모든 n &gt;= b 에 대해서 P(n)이 참이면, P(n + 1)도 참이다.</li></ul><h3 id="Referential-Transparency-참조-투명성"><a href="#Referential-Transparency-참조-투명성" class="headerlink" title="Referential Transparency (참조 투명성)"></a>Referential Transparency (참조 투명성)</h3><p>순수한 함수형 프로그램에서는 사이드 이펙트가 없기 때문에, reduction steps가 어떤 부분에 대해서도 동일하게 적용된다. 이를 Referential Transparency(참조 투명성)이라 한다.</p><p>structural induction은 natural induction과 비슷하다.<br>structural induction은 다음과 같이 동작한다.</p><ul><li>P(xs)이 모든 리스트 xs에 대해서</li><li>P(Nil)이 hold 된다면</li><li>리스트 xs와 어떤 element x에 대해서 P(xs)가 hold 되다면, P(x :: xs) 또한 hold 된다.</li></ul><p>이제 concat 함수를 다시 살펴보자</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def concat[<span class="string">T</span>](<span class="link">xs: List[T], ys: List[T]</span>) = xs match &#123;</div><div class="line">  case List() =&gt; ys</div><div class="line">  case x :: xs1 =&gt; x :: concat(xs1, ys)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>그리고 다음의 수식을 structural induction으로 증명해보자</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">(xs</span> <span class="literal">+</span><span class="literal">+</span> <span class="comment">ys)</span> <span class="literal">+</span><span class="literal">+</span> <span class="comment">zs</span> <span class="comment">=</span> <span class="comment">xs</span> <span class="literal">+</span><span class="literal">+</span> <span class="comment">(ys</span> <span class="literal">+</span><span class="literal">+</span> <span class="comment">zs)</span></div><div class="line"><span class="comment">//</span> <span class="literal">+</span><span class="literal">+</span><span class="comment">(concat)</span> <span class="comment">연산자의</span> <span class="comment">두가지</span> <span class="comment">정리를</span> <span class="comment">참고한다</span></div><div class="line"><span class="comment">//</span> <span class="comment">Nil</span> <span class="literal">+</span><span class="literal">+</span> <span class="comment">ys</span> <span class="comment">=</span> <span class="comment">ys</span></div><div class="line"><span class="comment">//</span> <span class="comment">(x</span> <span class="comment">::</span> <span class="comment">xs1)</span> <span class="literal">+</span><span class="literal">+</span> <span class="comment">ys</span> <span class="comment">=</span> <span class="comment">x</span> <span class="comment">::</span> <span class="comment">(xs1</span> <span class="literal">+</span><span class="literal">+</span> <span class="comment">ys)</span></div></pre></td></tr></table></figure><p>우선 xs에 Nil이 들어갈 때인 P(Nil)을 살펴보자</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// <span class="built_in">left</span> </div><div class="line">(Nil ++ ys) ++ zs</div><div class="line">= ys ++ zs      // by <span class="number">1</span>st clause of ++</div><div class="line"></div><div class="line">// <span class="built_in">right</span></div><div class="line">Nil ++ (ys ++ zs)</div><div class="line">= ys ++ zs      // by <span class="number">1</span>st clause of ++</div></pre></td></tr></table></figure><p>다음은 xs 대신에 induction step인 ‘x :: xs’를 넣어보자</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// left</span></div><div class="line"><span class="bullet">((x :: </span>xs) <span class="code">++ ys) +</span> zs</div><div class="line"><span class="section">= (x :: (xs ++ ys)) ++ zs      // by 2st clause of ++</span></div><div class="line"><span class="section">= x :: ((xs ++ ys) ++ zs)      // by 2st clause of ++</span></div><div class="line"><span class="section">= x :: (xs ++ (ys ++ zs))    // by induction hypothesis </span></div><div class="line"><span class="comment">// right</span></div><div class="line"><span class="bullet">(x :: </span>xs) <span class="code">++ (ys +</span>+ zs)</div><div class="line"><span class="section">= x :: (xs ++ (ys ++ zs))    // by 2st clause of ++</span></div></pre></td></tr></table></figure><p>좌변과 우변이 같으므로 함수 P는 증명됨</p><h2 id="5-7-A-Larger-Equational-Proof-on-Lists"><a href="#5-7-A-Larger-Equational-Proof-on-Lists" class="headerlink" title="5.7 A Larger Equational Proof on Lists"></a>5.7 A Larger Equational Proof on Lists</h2><p>좀더 까다로운 function인 reverse에 대해서 알아보자<br>다음의 두가지 amenable한 사실을 가지고 그 아래의 식을 증명해보자</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>) Nil<span class="selector-class">.reverse</span> = Nil               <span class="comment">// 1st clause</span></div><div class="line">(<span class="number">2</span>) (x :: xs)<span class="selector-class">.reverse</span> = xs<span class="selector-class">.reverse</span> ++ List(x)   <span class="comment">// 2nd clause</span></div><div class="line"></div><div class="line"><span class="comment">// 다음을 증명</span></div><div class="line">xs<span class="selector-class">.reverse</span><span class="selector-class">.reverse</span> = xs</div></pre></td></tr></table></figure><p>base case는 단순하다</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Nil.reverse.reverse</div><div class="line"><span class="section">= Nil.reverse</span></div><div class="line"><span class="section">= Nil</span></div></pre></td></tr></table></figure><p>이번엔 reduction step이다.</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// left</span></div><div class="line"><span class="bullet">(x :: </span>xs).reverse.reverse</div><div class="line"><span class="section">= (xs.reverse ++ List(x)).reverse     // by 2nd clause of reverse</span></div><div class="line"></div><div class="line"><span class="comment">// right</span></div><div class="line"><span class="bullet">x :: </span>xs</div><div class="line"><span class="section">= x :: xs.reverse.reverse       // by induction hypothesis (가설에 의해)</span></div></pre></td></tr></table></figure><p>두 개를 합쳐보면,</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(xs<span class="selector-class">.reverse</span> ++ List(x))<span class="selector-class">.reverse</span> = x :: xs<span class="selector-class">.reverse</span><span class="selector-class">.reverse</span></div></pre></td></tr></table></figure><p>직접적으로 induction이 불가하므로, 동일한 연산을 일반화 시켜보자<br>여기서는 xs.reverse를 ys로 치환하도록 하자. 그럼 수식이 아래와 같이 바뀐다.</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(ys ++ <span class="built_in">List</span>(x)).<span class="built_in">reverse</span> = x :: ys.<span class="built_in">reverse</span></div></pre></td></tr></table></figure><p>그럼 이제 두번째 induction인 ys를 증명하면 동일함을 입증할 수 있겠다.<br>우선 base case 부터 살펴보자</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// <span class="built_in">left</span></div><div class="line">(Nil ++ List(x)).reverse</div><div class="line">= List(x).reverse       // by <span class="number">1</span>st clause of ++</div><div class="line">= (x <span class="symbol">:</span><span class="symbol">:</span> Nil).reverse    // by definition of List</div><div class="line">= Nil.reverse ++ List(x)</div><div class="line">= Nil ++ (x <span class="symbol">:</span><span class="symbol">:</span> Nil)     // by <span class="number">2</span>nd clause of reverse</div><div class="line">= x <span class="symbol">:</span><span class="symbol">:</span> Nil          // by <span class="number">1</span>st clause of ++</div><div class="line">= x <span class="symbol">:</span><span class="symbol">:</span> Nil.reverse      // by <span class="number">1</span>st clause of reverse</div></pre></td></tr></table></figure><p>결과는 우변의 ys에 Nil을 집어넣었을 때와 동일한 결과과 도출되었으므로 base case를 증명되었다. 이제 reduction step으로 가보자</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// left</span></div><div class="line"><span class="bullet">((y :: </span>ys) ++ List(x)).reverse</div><div class="line"><span class="section">= (y :: (ys ++ List(x))).reverse    // by 2nd clause of ++</span></div><div class="line"><span class="section">= (ys ++ List(x)).reverse ++ List(y)  // by 2nd clause reverse</span></div><div class="line"><span class="section">= (x :: ys.reverse) ++ List(y)      // by the induction hypothesis</span></div><div class="line"><span class="section">= x :: (ys.reverse ++ List(y))      // by 1st clause of ++</span></div><div class="line"><span class="section">= x :: (y :: ys).reverse        // by 2nd clause of reverse</span></div><div class="line"></div><div class="line"><span class="comment">// right</span></div><div class="line"><span class="bullet">x :: </span>(y :: ys).reverse</div></pre></td></tr></table></figure><p>좌변과 우변이 동일하므로 증명되었다.</p><h3 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h3><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(xs ++ ys) <span class="built_in">map</span> <span class="attr">f</span> = (xs <span class="built_in">map</span> f) ++ (ys <span class="built_in">map</span> f)</div><div class="line"></div><div class="line">Nil <span class="built_in">map</span> <span class="attr">f</span> = Nil</div><div class="line">(x :: xs) <span class="built_in">map</span> <span class="attr">f</span> = f(x) :: (xs <span class="built_in">map</span> f)</div></pre></td></tr></table></figure><p>base case..</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// <span class="built_in">left</span></div><div class="line">(Nil ++ ys) map f</div><div class="line">= ys map f</div><div class="line"></div><div class="line">// <span class="built_in">right</span></div><div class="line">(Nil map f) ++ (ys map f)</div><div class="line">= Nil ++ (ys map f)</div><div class="line">= ys map f</div></pre></td></tr></table></figure><p>reduction step</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// left</span></div><div class="line"><span class="bullet">((x :: </span>xs) ++ ys) map f</div><div class="line"><span class="section">= (x :: (xs ++ ys)) map f</span></div><div class="line"><span class="section">= f(x) :: ((xs ++ ys) map f)</span></div><div class="line"><span class="section">= f(x) :: ((xs map f) ++ (ys map f))</span></div><div class="line"></div><div class="line"><span class="comment">// right</span></div><div class="line"><span class="bullet">((x :: </span>xs) map f) ++ (ys map f)</div><div class="line"><span class="section">= (f(x) :: (xs map f)) ++ (ys map f)</span></div><div class="line"><span class="section">= f(x) :: ((xs map f) ++ (ys map f))</span></div></pre></td></tr></table></figure><p>base case, reduction step 모두 좌변과 우변이 같으므로 같음이 증명되었다.</p><hr><ul class="pager"><li class="previous"><a href="/2016/07/26/2016-07-26-functional-programming-in-scala-week6/" data-toggle="tooltip" data-placement="top" title="Functional Programming in Scala week 6">&larr; Previous Post</a></li><li class="next"><a href="/2016/07/26/2016-07-26-functional-programming-in-scala-week4/" data-toggle="tooltip" data-placement="top" title="Functional Programming in Scala week 4">Next Post &rarr;</a></li></ul><div class="comment"><div id="disqus_thread" class="disqus-thread"></div></div></div><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 sidebar-container"><section><h5><a href="/tags/">FEATURED TAGS</a></h5><div class="tags"><a class="tag" href="/tags/#scala" title="scala">scala</a> <a class="tag" href="/tags/#coursera" title="coursera">coursera</a></div></section></div></div></div></article><script type="text/javascript">var disqus_shortname="bonogithub",disqus_identifier="http://blueshw.githup.io/2016/07/26/2016-07-26-functional-programming-in-scala-week5/",disqus_url="http://blueshw.githup.io/2016/07/26/2016-07-26-functional-programming-in-scala-week5/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script>function async(e,n){var t=document,a="script",r=t.createElement(a),c=t.getElementsByTagName(a)[0];r.src=e,n&&r.addEventListener("load",function(e){n(null,e)},!1),c.parentNode.insertBefore(r,c)}</script><script>async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){anchors.options={visible:"always",placement:"right",icon:"#"},anchors.add().remove(".intro-header h1").remove(".subheading").remove(".sidebar-container h5")})</script><style>@media all and (min-width:800px){.anchorjs-link{position:absolute;left:-.75em;font-size:1.1em;margin-top:-.1em}}</style><footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a target="_blank" href="https://www.facebook.com/blueshw"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-facebook fa-stack-1x fa-inverse"></i></span></a></li><li><a target="_blank" href="https://github.com/blueshw"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 보노의 블로그 2017<br>Theme by <a href="http://huangxuan.me">Hux</a> <span style="display:inline-block;margin:0 5px"><i class="fa fa-heart"></i> </span>Ported by <a href="http://blog.kaijun.rocks">Kaijun</a> |<iframe style="margin-left:2px;margin-bottom:-5px" frameborder="0" scrolling="0" width="91px" height="20px" src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true"></iframe></p></div></div></div></footer><script src="/js/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/hux-blog.min.js"></script><script>function async(e,n){var t=document,a="script",r=t.createElement(a),c=t.getElementsByTagName(a)[0];r.src=e,n&&r.addEventListener("load",function(e){n(null,e)},!1),c.parentNode.insertBefore(r,c)}</script><script>0!==$("#tag_cloud").length&&async("http://blueshw.githup.io/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js",function(){var c=document.querySelector("nav");c&&FastClick.attach(c)})</script><script>var _gaId="UA-50048807-2",_gaDomain="blueshw.github.io";!function(e,a,n,t,g,o,c){e.GoogleAnalyticsObject=g,e[g]=e[g]||function(){(e[g].q=e[g].q||[]).push(arguments)},e[g].l=1*new Date,o=a.createElement(n),c=a.getElementsByTagName(n)[0],o.async=1,o.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(o,c)}(window,document,"script",0,"ga"),ga("create",_gaId,_gaDomain),ga("send","pageview")</script><img src="http://blueshw.githup.io/img/icon_wechat.png" width="0" height="0"></body></html>