<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="R3ZeY1PmaJUY9j_cgNABjesJFgHWVCJpb4TsdfXntMA"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content=""><meta name="keyword" content=""><link rel="shortcut icon" href="/img/favicon2.ico"><link rel="canonical" href="http://blueshw.github.io/2017/07/01/arrow-function/"><title>[ES6, react] 리액트에서 화살표 함수(arrow function)는 선택이 아닌 필수 - 보노의블로그 | Bono&#39;s Blog</title><link rel="canonical" href="http://blueshw.github.io/2017/07/01/arrow-function/"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/hux-blog.css"><link rel="stylesheet" href="/css/highlight.css"><link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]--><script></script></head><body ontouchstart=""><nav class="navbar navbar-default navbar-fixed-top"><div class="container-fluid"><div class="navbar-header page-scroll"><button type="button" class="navbar-toggle"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand" href="/">보노의 블로그</a></div><div id="huxblog_navbar"><div class="navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="/">Home</a></li><li><a href="/about/">About</a></li><li><a href="/archives/">Archives</a></li><li><a href="/tags/">Tags</a></li></ul></div></div></div></nav><script>function handleMagic(e){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic)</script><style type="text/css"></style><header class="intro-header"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-heading"><div class="tags"><a class="tag" href="/tags/#javascript" title="javascript">javascript</a> <a class="tag" href="/tags/#react" title="react">react</a> <a class="tag" href="/tags/#arrow function" title="arrow function">arrow function</a> <a class="tag" href="/tags/#es6" title="es6">es6</a> <a class="tag" href="/tags/#bind" title="bind">bind</a> <a class="tag" href="/tags/#this" title="this">this</a></div><h1>[ES6, react] 리액트에서 화살표 함수(arrow function)는 선택이 아닌 필수</h1><h2 class="subheading"></h2><span class="meta">Posted by bono on 2017-07-01</span></div></div></div></div></header><article><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container"><p>리액트를 개발하다보면 이런 코드를 본적 있을것입니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.someFunction.bind(<span class="keyword">this</span>);</div></pre></td></tr></table></figure><p>this(아마도 react 클래스 객체)에 속한 어떤 메서드를 다시 this에 bind한다라?? 굳이 왜 이런짓을 해야하는지 의문이 들만합니다.</p><p>리액트에서 이러한 코드가 빈번하게 작성되는 이유를 알기 위해서 우선 <code>bind()</code>가 무슨 역할을 하는지부터 알아보겠습니다.</p><h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><p>bind 함수는 바인드하는 함수에서 사용하는 <code>this</code>의 대상을 지정해주는 역할을 합니다. 잘 사용하지 않아서 그렇지 그다지 어려운 개념은 아닙니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> objA = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"a"</span>,</div><div class="line">    <span class="attr">aFunc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> objB = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"b"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">objA.aFunc(); <span class="comment">// (1)</span></div><div class="line"><span class="comment">// a</span></div><div class="line">objA.aFunc.bind(objB); <span class="comment">// (2)</span></div><div class="line"><span class="keyword">const</span> foo = objA.aFunc.bind(objB); <span class="comment">// (3)</span></div><div class="line">foo(); (<span class="number">4</span>)</div><div class="line"><span class="comment">// b</span></div></pre></td></tr></table></figure><p><code>objA</code>와 <code>objB</code>라는 객체가 있습니다. objA 객체는 <code>name</code>이라는 값과 <code>aFunc</code>라는 함수를 속성으로 가지고 있습니다. 반면 objB 객체는 <code>name</code>이라는 값만 가지고 있죠.</p><p>(1) objA의 aFunc함수를 실행하면 예상대로 <code>a</code>가 출력됩니다.</p><p>(2) objA 객체의 aFunc 함수에서 bind(objB)를 호출합니다. 함수가 호출되었지만, 아무것도 출력되지 않죠. 다만, 원본 aFunc함수와 동일한 기능을 하는 바인딩된 새로운 함수가 만들어집니다. 이때, bind메서드에 전해진 인자는 복사된 바인딩 함수의 this로 전달됩니다. 즉, aFunc 함수내의 <code>this</code>가 <code>objB</code>가 되는 것이죠. 이게 <code>bind()함수</code>가 하는 일의 전부입니다.</p><p>(3) 바인드 함수를 변수에 할당합니다.</p><p>(4) 실행하면 <code>b</code>가 출력됩니다.</p><h3 id="React에서의-bind"><a href="#React에서의-bind" class="headerlink" title="React에서의 bind()"></a>React에서의 bind()</h3><p>처음 잠깐 살펴보았지만, 리액트에서 bind()함수는 다음과 같이 사용됩니다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="type">React</span> from <span class="symbol">'reac</span>t';</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BindTest</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    handleClick() &#123;</div><div class="line">        console.log(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> &lt;button <span class="class"><span class="keyword">type</span></span>=<span class="string">"button"</span> onClick=&#123;<span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)&#125;&gt;<span class="type">Goodbye</span> bind&lt;/button&gt;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">export <span class="keyword">default</span> <span class="type">BindTest</span>;</div></pre></td></tr></table></figure><p>간단한 React 컴포넌트입니다. 버튼을 클릭하면 <code>this</code>에 해당하는 정보가 출력됩니다.</p><img src="/2017/07/01/arrow-function/bind.png" alt="bind.png"><p>버튼 태그의 onClick 속성을 보면 bind() 함수가 사용되고 있는걸 알수 있습니다. 근데 좀 이상합니다. this의 handleClick 함수에다가 this 객체를 바인드시켰습니다. 같은 this인데 굳이 또 바인드해주는 이유가 뭘까요? bind 함수를 빼보겠습니다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="type">React</span> from <span class="symbol">'reac</span>t';</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithoutBindTest</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    handleClick() &#123;</div><div class="line">        console.log(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> &lt;button <span class="class"><span class="keyword">type</span></span>=<span class="string">"button"</span> onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;<span class="type">Goodbye</span> bind without <span class="keyword">this</span>&lt;/button&gt;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">export <span class="keyword">default</span> <span class="type">WithoutBindTest</span>;</div></pre></td></tr></table></figure><p>어떤 결과가 나올까요?</p><img src="/2017/07/01/arrow-function/withoutbind.png" alt="withoutbind.png"><p><code>null</code>이 출력되었습니다. 왜 null이 출력되었을까요?</p><p>이 내용을 이해하려면 자바스크립트에서의 <code>this</code>에 대해 어느정도 알고 있어야 합니다.</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>객체지향 언어에서의 일반적인 this의 의미(현재 객체를 지칭)와는 달리 자바스크립트의 this는 실행시의 context를 말하죠. 아래 예제를 보면,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> thisTest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</div><div class="line">&#125;</div><div class="line">thisTest.value = <span class="string">"I am this"</span>;</div><div class="line">thisTest();</div></pre></td></tr></table></figure><p><code>&quot;I am this&quot;</code>가 나올거라는 예상과는 달리 <code>undefined</code>가 출력됩니다. 왜냐하면 <code>thisTest()</code>가 출력될 때의 context가 전역객체이기 때문입니다. thisTest.value는 thisTest에 속성인데 전역객체에서 value를 찾으려고 하니 undefined가 나올수 밖에 없습니다(window 객체가 아니라 undefined인 이유는 React가 기본적으로 strict 모드에서 실행되기 때문입니다).</p><p>“I am this”를 출력하려면, this에 해당하는 객체의 메서드를 호출하면 this.value값을 가져올 수 있습니다. 아래 예제를 보면,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> thisTest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</div><div class="line">&#125;</div><div class="line">thisTest.value = <span class="string">"I am this"</span>;</div><div class="line">thisTest.func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</div><div class="line">&#125;</div><div class="line">thisTest.func();</div></pre></td></tr></table></figure><p><code>thisTest.func</code> 함수를 만들어서 그안에서 <code>this.value</code>를 출력합니다. thisTest 객체의 func() 메서드를 호출하면 이 때는 <code>this</code>가 thisTest가 되기 때문에 정상적으로 this.value를 가져와 “I am this”를 출력합니다.</p><p>이제, 리액트로 다시 돌아가보죠.</p><h3 id="React에서의-this"><a href="#React에서의-this" class="headerlink" title="React에서의 this"></a>React에서의 this</h3><p>WithoutBindTest 클래스의 render() 함수를 다시 살펴보겠습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">render() &#123;</div><div class="line">    <span class="keyword">return</span> &lt;button type=<span class="string">"button"</span> onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Goodbye bind without <span class="keyword">this</span>&lt;/button&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>컴포넌트의 render()함수가 실행되면 DOM이 그려질것입니다. 이때 this는 WithoutBindTest 객체를 가리키는것이 맞습니다. 하지만 handleClick()함수가 호출될때의 this는 WithoutBindTest가 아닌 전역객체(Window)를 의미합니다. 왜냐하면 this라는 값은 호출하는 문맥(context)에의해 좌우되는데 클릭이 실행되는 문맥이 바로 전역(window)객체이기 때문이죠.</p><h3 id="Arrow-Function"><a href="#Arrow-Function" class="headerlink" title="Arrow Function"></a>Arrow Function</h3><p>click, change 등의 이벤트 리스너를 붙여줄때마다 <code>bind()</code>함수를 작성하는건 귀찮은 일입니다. ES6의 <code>화살표함수</code>를 사용하면 이 문제를 간단히 해결할 수 있습니다. BindTest를 화살표 함수를 이용해 새로 작성해보았습니다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="type">React</span> from <span class="symbol">'reac</span>t';</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BindTest</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    handleClick = () =&gt; &#123;</div><div class="line">        console.log(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> &lt;button <span class="class"><span class="keyword">type</span></span>=<span class="string">"button"</span> onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;<span class="type">Goodbye</span> bind&lt;/button&gt;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">export <span class="keyword">default</span> <span class="type">BindTest</span>;</div></pre></td></tr></table></figure><p>이제는 this가 무엇인지 걱정할 필요가 없습니다. 화살표 함수의 this는 외부함수(부모함수)의 this를 상속받기 때문에 this는 항상 일정합니다. 위 예제의 경우에는 BindTest 클래스(사실 함수입니다)가 되겠죠.</p><h3 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h3><blockquote><p>bind()함수는 전달된 인자를 this로 보내는 바인딩 함수를 만듭니다.<br>this는 다른 언어와 달리 실행 문맥(context)에 따라 변합니다.<br>React에서 이벤트 핸들러 함수를 바인드할때 화살표 함수를 사용합니다.</p></blockquote><hr><ul class="pager"><li class="next"><a href="/2017/06/26/presentaional-component-container-component/" data-toggle="tooltip" data-placement="top" title="[번역] 프레젠테이션 컴포넌트와 컨테이너 컴포넌트">Next Post &rarr;</a></li></ul><div class="comment"><div id="disqus_thread" class="disqus-thread"></div></div></div><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 sidebar-container"><section><h5><a href="/tags/">FEATURED TAGS</a></h5><div class="tags"><a class="tag" href="/tags/#javascript" title="javascript">javascript</a> <a class="tag" href="/tags/#react" title="react">react</a> <a class="tag" href="/tags/#arrow function" title="arrow function">arrow function</a> <a class="tag" href="/tags/#es6" title="es6">es6</a> <a class="tag" href="/tags/#bind" title="bind">bind</a> <a class="tag" href="/tags/#this" title="this">this</a></div></section></div></div></div></article><script type="text/javascript">var disqus_shortname="bonogithub",disqus_identifier="http://blueshw.github.io/2017/07/01/arrow-function/",disqus_url="http://blueshw.github.io/2017/07/01/arrow-function/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a target="_blank" href="https://www.facebook.com/blueshw" rel="external nofollow noopener noreferrer"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-facebook fa-stack-1x fa-inverse"></i></span></a></li><li><a target="_blank" href="https://github.com/blueshw" rel="external nofollow noopener noreferrer"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 보노의 블로그 2017</p></div></div></div></footer><script src="/js/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/hux-blog.min.js"></script><script>function async(e,n){var t=document,a="script",r=t.createElement(a),c=t.getElementsByTagName(a)[0];r.src=e,n&&r.addEventListener("load",function(e){n(null,e)},!1),c.parentNode.insertBefore(r,c)}</script><script>0!==$("#tag_cloud").length&&async("http://blueshw.github.io/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js",function(){var c=document.querySelector("nav");c&&FastClick.attach(c)})</script><script>var _gaId="UA-50048807-2",_gaDomain="blueshw.github.io";!function(e,a,n,t,g,o,c){e.GoogleAnalyticsObject=g,e[g]=e[g]||function(){(e[g].q=e[g].q||[]).push(arguments)},e[g].l=1*new Date,o=a.createElement(n),c=a.getElementsByTagName(n)[0],o.async=1,o.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(o,c)}(window,document,"script",0,"ga"),ga("create",_gaId,_gaDomain),ga("send","pageview")</script><img src="http://blueshw.github.io/img/icon_wechat.png" width="0" height="0"></body></html>