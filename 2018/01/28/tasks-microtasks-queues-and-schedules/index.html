<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="R3ZeY1PmaJUY9j_cgNABjesJFgHWVCJpb4TsdfXntMA"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content=""><meta name="keyword" content=""><link rel="shortcut icon" href="/img/favicon2.ico"><link rel="canonical" href="http://blueshw.github.io/2018/01/28/tasks-microtasks-queues-and-schedules/"><title>[번역] Tasks, microtasks, queues and schedules - 보노의블로그 | Bono&#39;s Blog</title><link rel="canonical" href="http://blueshw.github.io/2018/01/28/tasks-microtasks-queues-and-schedules/"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/hux-blog.css?v=20180917"><link rel="stylesheet" href="/css/highlight.css"><link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]--><script></script></head><body ontouchstart=""><nav class="navbar navbar-default navbar-fixed-top"><div class="container-fluid"><div class="navbar-header page-scroll"><button type="button" class="navbar-toggle"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand" href="/">보노의 블로그</a></div><div id="huxblog_navbar"><div class="navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="/">Home</a></li><li><a href="/about/">About</a></li><li><a href="/archives/">Archives</a></li><li><a href="/tags/">Tags</a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");function handleMagic(e){0<$navbar.className.indexOf("in")?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}$toggle.addEventListener("click",handleMagic)</script><style type="text/css"></style><header class="intro-header"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-heading"><div class="tags"><a class="tag" href="/tags/#javascript" title="javascript">javascript</a> <a class="tag" href="/tags/#task" title="task">task</a> <a class="tag" href="/tags/#microtask" title="microtask">microtask</a> <a class="tag" href="/tags/#Promise" title="Promise">Promise</a></div><h1>[번역] Tasks, microtasks, queues and schedules</h1><h2 class="subheading"></h2><span class="meta">Posted by bono on 2018-01-28</span></div></div></div></div></header><article><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container"><blockquote><p>원본: <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" rel="external nofollow noopener noreferrer" target="_blank">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/</a><br>의역, 오역이 가득합니다. 개인적으로 정확한 개념을 잡기 위한 번역입니다. 불필요하다 생각한 내용은 과감히 제거했습니다.<br>테스트는 원본 페이지에서 확인 가능합니다.</p></blockquote><p>아래 자바스크립트 코드를 살펴보자.<br></p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Promise.resolve().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure><p></p><p>위의 코드를 실행하면 아래와 같은 순서로 출력된다.<br></p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">script start</span><br><span class="line">script end</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure><p></p><p>브라우저에 따라서 조금 다른데 Microsoft Edge, Firefox 40, iOS Safari, desktop Safari 8.0.8에서는 예외적으로 <code>setTimeout</code>이 <code>promise1</code>, <code>promise2</code>보다 먼저 출력된다. 진짜 이상한점은 Firefox 39, Safari 8.0.7에서는 정상적으로 출력된다는 것이다.</p><h3 id="왜-이렇게-출력되는-것일까"><a href="#왜-이렇게-출력되는-것일까" class="headerlink" title="왜 이렇게 출력되는 것일까?"></a>왜 이렇게 출력되는 것일까?</h3><p>이를 이해하기 위해서는 우선 이벤트 루프가 <code>task</code>와 <code>microtask</code>를 어떻게 다루는지에 대해 알 필요가 있다.</p><p>스레드는 그 자신의 이벤트 루프를 가지고 있고 각각의 web worker는 자신의 이벤트 루프를 수행하기 때문에 서로 독립적으로 실행된다. 그러나 같은 도메인(origin)의 모든 브라우저 창들은 동기적으로 통신할 수 있기 때문에 이벤트 루프를 서로 공유한다. 이벤트 루프는 지속적으로 돌아가면서, 대기열에 들어가있는 task들을 실행시킨다. 한 이벤트 루프는 실행 순서를 보장하는 여러개의 task를 가지고 있지만 각 이벤트 루프의 실행단계에서 어떤 task를 실행시킬지는 브라우저가 선택한다. 이를 통해 브라우저는 유저 input과 같은 성능에 민감한 task에 우선권을 부여할 수 있다.</p><p>task는 브라우저 내부에서 javascript/DOM으로 들어가 순차적으로 발생하도록 예약된다. task 사이에서 브라우저는 렌더링을 새로한다. 마우스 클릭으로 이벤트 콜백을 발생시키려면 HTML 파싱 처럼 task예약이 필요하다. 위에서 보았던 <code>setTimeout</code>이 좋은 사례이다.</p><p><code>setTimeout</code>은 주어진 delay를 기다린 다음 콜백을 위한 새로운 task를 예약한다. 이것이 <code>setTimeout</code>로그가 <code>script end</code>로그 이후에 출력되는 이유이다. <code>script end</code>로그는 첫번째 task의 일부이고 <code>setTimeout</code>은 별도의 task에서 발생한 로그이다.</p><p>일반적으로 microtask는 현재 실행되고 있는 script 바로 다음에 발생해야하는 작업으로 예약된다. 예를들어 일괄처리에 대한 반응(?)이나 새로운 task를 만들때의 단점 없이 비동기로 어떤 작업을 처리하기 위해 사용된다. microtask의 대기열은 다른 자바스크립트가 실행중이 아니거나 task가 끝난 후에 처리된다. 대기중인 microtask는 대기열의 끝에 더해지고 실행된다. <code>observer callback</code>이나 <code>promise callback</code>이 대표적인 microtask다.</p><p>promise가 처리될 때 혹은 이미 처리된 promise는 callback을 처리하기 위해 microtask의 대기열에 들어간다. 이눈 promise가 처리 여부와 상관없이 그 callbak이 비동기로 실행됨을 보장한다. 즉, 처리된 promise에 대해서 <code>then(resolve, reject)</code>이 호출되면 그 즉시 microtask가 대기열에 들어간다. 이것이 바로 <code>promise1</code>과 <code>promise2</code>가 <code>script end</code> 다음에 출력되는 이유이다. 현재 실행되는 script(task)가 끝난 다음에 반드시 microtask가 처리되어야 한다. <code>promise1</code>과 <code>promise2</code>가 <code>setTimeout</code> 이전에 출력되는 이유는 microtask가 다음에 실행될 task 이전에 처리되기 때문이다.</p><p>위 코드를 다시 살펴보면 아래와 같은 순서로 처리됨을 알 수 있다.</p><blockquote><p>원문에서 확인함을 추천, 원문에는 animation으로 코드의 실행과정과 task queue 및 js 실행 스택을 확인할 수 있다.</p></blockquote><figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 - task1 실행: script, script start 출력</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 - task2 등록: timer task 대기열에 들어감</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> &#123;</span></span><br><span class="line">  <span class="comment">// 8 - task2 실행</span></span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 - microtask1 등록: promise가 microtask 대기열에 들어감</span></span><br><span class="line">Promise.resolve().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span> &#123;</span></span><br><span class="line">  <span class="comment">// 5 - microtask1 실행: promise1 출력</span></span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'promise1'</span>);</span><br><span class="line"><span class="comment">// 6 - microtask2 등록: </span></span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span> &#123;</span></span><br><span class="line">  <span class="comment">// 7 - microtask2 실행: promise2 출력</span></span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 - task1 종료: script end 출력</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure><h3 id="그럼-어떤-브라우저에서는-왜-다르게-동작할까"><a href="#그럼-어떤-브라우저에서는-왜-다르게-동작할까" class="headerlink" title="그럼 어떤 브라우저에서는 왜 다르게 동작할까?"></a>그럼 어떤 브라우저에서는 왜 다르게 동작할까?</h3><p>위에서 언급한 특정 브라우저에서는 <code>promise1</code>과 <code>promise2</code>가 두번째 task인 <code>setTimeout</code> 이후에 출력된다. 이때는 promise가 microtask가 아닌 새로운 task로 인식되어 <code>setTimeout</code> task 이후에 출력되는 것이 아닐까 생각된다.</p><p>promise가 HTML이 아니라 ECMAScript에서 나왔기 때문에 변명의 여지가 있어보입니다. ECMAScript는 microtask와 비슷한 job의 개념을 가지고 있다. 그러나 그 관계가 명확한 것은 아니지만(<a href="https://esdiscuss.org/topic/the-initialization-steps-for-web-browsers#content-16" rel="external nofollow noopener noreferrer" target="_blank">vague mailing list discussions</a>), 일반적으로 promise는 microtask 대기열의 일부로 받아들여지고 있다.</p><p>promise를 task로써 다룰 때는 성능상 문제가 발생할 수 있는데, promise callback이 렌더링과 같은 task 관련 작업들에 의해 불필요하게 연기될수도 있기 때문이다. 또한 이는 다른 자바스크립트 소스와의 상호작용으로 인해서 무결성이 훼손될수도 있고 그로인해 다른 API와의 상호작용이 깨질수도 있다.</p><p>해당 이슈는 Edge 브라우저에서 이미 완결되었다(<a href="https://connect.microsoft.com/IE/feedback/details/1658365" rel="external nofollow noopener noreferrer" target="_blank">Edge ticket</a>).</p><h3 id="task인지-microtask인지는-어떻게-알수-있을까"><a href="#task인지-microtask인지는-어떻게-알수-있을까" class="headerlink" title="task인지 microtask인지는 어떻게 알수 있을까?"></a>task인지 microtask인지는 어떻게 알수 있을까?</h3><p>테스트 방법은 하나다. 비록 올바르게 구현됐다는 가정이 필요하지만, promise와 <code>setTimeout</code>과 관련된 로그의 출력을 보면 알 수 있다.</p><p>더 확실한 방법은 스펙을 찾아보면 된다. 예를들어 task가 대기열에 들어가는 과정을 나타낸 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#timer-initialisation-steps" rel="external nofollow noopener noreferrer" target="_blank">step 14 of setTimeout</a>을 살펴볼 수 있고, microtask가 큐에 들어가는 과정을 나타낸 <a href="https://dom.spec.whatwg.org/#queue-a-mutation-record" rel="external nofollow noopener noreferrer" target="_blank">step 5 of queueing a mutation record</a>를 보면 좀 더 자세하게 알 수 있다.</p><p>이미 얘기한것 처럼 ECMAScript에서는 microtask는 job으로 불린다. <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-performpromisethen" rel="external nofollow noopener noreferrer" target="_blank">step 8 .a PerformPromiseThen</a>을 보면, EnqueueJob은 microtask 대기열에서 호출됨을 알 수 있다.</p><p>다음에는 좀더 복잡한 예제를 살펴보자.</p><h3 id="Level-1-bossfight"><a href="#Level-1-bossfight" class="headerlink" title="Level 1 bossfight"></a>Level 1 bossfight</h3><p>아래에 간단한 html이 있다.<br></p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"outer"</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"inner"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><p></p><p>그리고 아래 자바스크립트 코드 일부가 있다. 이때 <code>div .inner</code>를 클릭하면 로그가 어떻게 출력될까?</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// outer 클래스 element와 inner 클래스 element를 가져온다.</span></span><br><span class="line"><span class="keyword">var</span> outer = <span class="built_in">document</span>.querySelector(<span class="string">'.outer'</span>);</span><br><span class="line"><span class="keyword">var</span> inner = <span class="built_in">document</span>.querySelector(<span class="string">'.inner'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// outer element의 상태(attribute) 변화를 감시한다.</span></span><br><span class="line"><span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'mutate'</span>);</span><br><span class="line">&#125;).observe(outer, &#123;</span><br><span class="line">  attributes: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// click 리스너</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'click'</span>);</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  outer.setAttribute(<span class="string">'data-random'</span>, <span class="built_in">Math</span>.random());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inner, outer element에 클릭 이벤트를 붙인다.</span></span><br><span class="line">inner.addEventListener(<span class="string">'click'</span>, onClick);</span><br><span class="line">outer.addEventListener(<span class="string">'click'</span>, onClick);</span><br></pre></td></tr></table></figure><p><code>div.inner</code>를 클릭했을 때와, <code>div .outer</code>를 클릭했을때 어떻게 다른지 알겠는가? 당신이 여전히 맞을수도 있겠지만 불행하게도 브라우저마다 동일한 결과를 보여주지는 않는다(버전 명시가 안되있어서 현재 최신 버전에서도 동일할지는 테스트가 필요하겠다).</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Chrome : </span><br><span class="line">click - promise - mutate - click - promise - mutate - <span class="keyword">timeout</span> - <span class="keyword">timeout</span></span><br><span class="line"></span><br><span class="line">Firefox : </span><br><span class="line">click - mutate - click - mutate - <span class="keyword">timeout</span> - promise - promise - <span class="keyword">timeout</span></span><br><span class="line"></span><br><span class="line">Safari : </span><br><span class="line">click - mutate - click - mutate - promise - promise - <span class="keyword">timeout</span> - <span class="keyword">timeout</span></span><br><span class="line"></span><br><span class="line">Edge</span><br><span class="line">click - click - mutate - <span class="keyword">timeout</span> - promise - <span class="keyword">timeout</span> - promise</span><br></pre></td></tr></table></figure><h3 id="어떤-브라우저가-맞을까"><a href="#어떤-브라우저가-맞을까" class="headerlink" title="어떤 브라우저가 맞을까?"></a>어떤 브라우저가 맞을까?</h3><p>클릭 이벤트를 전달하는것은 하나의 task다(즉, <code>div .inner</code>에서 클릭이 발생해서 <code>div .outer</code>로 버블링되더라도 두개의 동작이 별도의 task가 아니라 하나의 task라는 의미). Mutation observer나 promise callback은 microtask로 대기열에 들어가고 <code>setTimeout</code> 콜백은 task로 대기열에 들어간다. 즉 아래와 같은 방식으로 처리된다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 - task1 실행: script 실행</span></span><br><span class="line"><span class="keyword">var</span> outer = <span class="built_in">document</span>.querySelector(<span class="string">'.outer'</span>);</span><br><span class="line"><span class="keyword">var</span> inner = <span class="built_in">document</span>.querySelector(<span class="string">'.inner'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 8 - microtask2 실행: mutation observer 콜백 실행</span></span><br><span class="line">  <span class="comment">// 13 - microtask4 실행: mutation observer 콜백 실행</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'mutate'</span>);</span><br><span class="line">&#125;).observe(outer, &#123;</span><br><span class="line">  attributes: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 - task2 등록 및 실행: inner 영역 click 이벤트 발생</span></span><br><span class="line"><span class="comment">// 9 - task2 계속 실행 : inner에서 outer로 click 이벤트 버블링</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'click'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 4 - task3 등록: inner 영역 타이머 task 생성, setTimeout</span></span><br><span class="line">  <span class="comment">// 10 - task4 등록: outer 영역 타이머 task 생성, setTimeout</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 14 - task3 실행: inner 영역 타이머 콜백 실행</span></span><br><span class="line">    <span class="comment">// 15 - task4 실행: outer 영역 타이머 콜백 실행</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 5 - microtask1 등록: inner 영역 promise</span></span><br><span class="line">  <span class="comment">// 11 - microtask3 등록: outer 영역 promise</span></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 7 - microtask1 실행 : inner 영역의 promise 콜백 실행</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6 - microtask2 등록: inner 영역 Mutation observer</span></span><br><span class="line">  <span class="comment">// 12 - microtask4 등록: outer 영역 Mutation observer 등록</span></span><br><span class="line">  outer.setAttribute(<span class="string">'data-random'</span>, <span class="built_in">Math</span>.random());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 - task1 종료 : inner 및 outer element에 click 이벤트 리스너 등록</span></span><br><span class="line">inner.addEventListener(<span class="string">'click'</span>, onClick);</span><br><span class="line">outer.addEventListener(<span class="string">'click'</span>, onClick);</span><br></pre></td></tr></table></figure><p>역시 크롬이 맞다(글 작성자가 구글 직원이다). 다른 자바스크립트가 실행되고 있지 않다고 가정하고 microtask가 task의 끝에서 처리된다기 보다는 콜백들이 모두 처리된 이후에 처리된다고 보는게 맞다. 이 규칙은 콜백을 호출하는 HTML 스펙에 잘 정의되어 있다.</p><blockquote><p>만약 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#stack-of-script-settings-objects" rel="external nofollow noopener noreferrer" target="_blank">자바스크립트 스택</a>이 비어있다면 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint" rel="external nofollow noopener noreferrer" target="_blank">microtask가 실행될지를 체크</a>하다.<br>- <a href="https://html.spec.whatwg.org/multipage/webappapis.html#clean-up-after-running-a-callback" rel="external nofollow noopener noreferrer" target="_blank">HTML: Cleaning up after a callback</a> step 3</p></blockquote><p>microtask 대기열이 처리중이 아니라면 microtask 수행 체크는 microtask 대기열을 지나가버린다. 비슷하게 ECMAScript는 jobs에 대해 이렇게 말한다.</p><blockquote><p>job의 실행은 단지 실행 컨택스트가 동작하지 않을때만 초기화된다.<br><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues" rel="external nofollow noopener noreferrer" target="_blank">ECMAScript: Jobs and Job Queues</a></p></blockquote><h3 id="다른-브라우저들은-뭐가-잘못됐을까"><a href="#다른-브라우저들은-뭐가-잘못됐을까" class="headerlink" title="다른 브라우저들은 뭐가 잘못됐을까?"></a>다른 브라우저들은 뭐가 잘못됐을까?</h3><p>Firefox와 Safari에서는 mutation 콜백에서 보여줬듯이 클릭 리스너 사이에 microtask 대기열을 제대로 소진시킨다. 그러나 promise는 좀 더 다른 방식으로 큐에 삽입된다. job과 microtask의 연관성이 모호하다는 것을 감안하더라도 여전히 콜백 사이에서 실행될것이라 기대된다. Firefox 이슈를 확인해보자(<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1193394" rel="external nofollow noopener noreferrer" target="_blank">Firefox ticket</a>, <a href="https://bugs.webkit.org/show_bug.cgi?id=147933" rel="external nofollow noopener noreferrer" target="_blank">Safari ticket</a>).</p><p>이전에 살펴보았듯이 Edge에서는 promise가 제대로 동작하지 않는다(task로 인식). 그리고 또다른 문제는 microtask 대기열이 클릭 리스너 사이에서 소진되는 것이 아니라 모든 리스너가 호출된 다음에 호출된다. 이것이 두 클릭 로그 이후에 하나의 mutate가 찍힌 이유다.(<a href="https://connect.microsoft.com/IE/feedbackdetail/view/1658386/microtasks-queues-should-be-processed-following-event-listeners" rel="external nofollow noopener noreferrer" target="_blank">Bug ticket</a>)</p><h3 id="Level-1-boss’s-angry-older-brother-왜-이런-표현을-쓸까"><a href="#Level-1-boss’s-angry-older-brother-왜-이런-표현을-쓸까" class="headerlink" title="Level 1 boss’s angry older brother (왜 이런 표현을 쓸까..?)"></a>Level 1 boss’s angry older brother (왜 이런 표현을 쓸까..?)</h3><p>그렇다면 아래처럼 자바스크립트에서 직접 click 함수를 호출하는 경우에는 어떨까?<br></p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 위 코드와 동일, 직접 리스너를 호출하는 아래 코드만 추가</span></span><br><span class="line">inner.<span class="built_in">click</span>();</span><br></pre></td></tr></table></figure><p></p><p>조금 다른 결과가 나왔다. 브라우저 별로 어떻게 다른지도 살펴보자</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Chrome : </span><br><span class="line">click - click - promise - mutate - promise - <span class="keyword">timeout</span> - <span class="keyword">timeout</span></span><br><span class="line"></span><br><span class="line">Firefox : </span><br><span class="line">click - click - mutate - <span class="keyword">timeout</span> - promise - promise - <span class="keyword">timeout</span></span><br><span class="line"></span><br><span class="line">Safari : </span><br><span class="line">click - click - mutate - promise - promise - <span class="keyword">timeout</span> - <span class="keyword">timeout</span></span><br><span class="line"></span><br><span class="line">Edge</span><br><span class="line">click - click - mutate - <span class="keyword">timeout</span> - promise - <span class="keyword">timeout</span> - promise</span><br></pre></td></tr></table></figure><p>다른 브라우저는 제쳐두고서라도 크롬에서도 다른 결과가 발생했다(이와중에 Edge는 동일하다). 여러번 테스트 해보아도 동일한 결과가 나온다.</p><h3 id="왜-다른것일까"><a href="#왜-다른것일까" class="headerlink" title="왜 다른것일까?"></a>왜 다른것일까?</h3><p>그 이유는 자바스크립트 코드 마지막에서 <code>inner.click()</code>이 실행되면 script가 아직 종료되기 전이므로 자바스크립트 스택이 비어있지 않은 상태가 된다(자바 스크립트 스택이 비어 있지 않으므로 microtask를 처리할 수 없다). 그렇기 때문에 microtask가 실행되지 않고 바로 outer로 버블링되어 클릭 리스너가 실행되는 것이다.<br>(mutate가 한번만 출력되는 이유는 하나의 mutation microtask가 등록되어 있으면 다른 mutation task를 등록할 수 없기 때문)</p><p>결론은 역시(?) 크롬이 제대로된 결과를 출력한다는 것.</p><p>위에서 언급했던것 처럼 리스너 콜백이 호출된 후 자바스크립트 실행 스택이 비어있는 경우에만 microtask 체크를 수행하기 때문에 <code>inner.click()</code>으로 메서드가 호출중인 상태에서는 microtask 체크가 진행되지 않는다.</p><p>이전에 보았던 예제에서는 microtask가 리스너 콜백 사이에서 실행되었지만(사용자에 의해 클릭 동작이 처리되었으므로) <code>.click()</code>은 동기적으로 이벤트가 전달되므로 <code>.click()</code>을 호출하는 스크립트는 여전히 콜백 사이의 스택에 남아있게 된다. 이 규칙은 자바스크립트가 실행중일 때는 microtask가 끼어들지 못한다는 것을 보장한다. 이는 우리가 리스너 콜백 사이에서 microtask를 처리하지 못하고 모든 리스너가 실행된 후에 처리된다는 것을 의미한다.</p><hr><ul class="pager"><li class="previous"><a href="/2018/02/27/async-await/" data-toggle="tooltip" data-placement="top" title="[javascript] async, await를 사용하여 비동기 javascript를 동기식으로 만들자">&larr; Previous Post</a></li><li class="next"><a href="/2017/07/01/arrow-function/" data-toggle="tooltip" data-placement="top" title="[ES6, react] 리액트에서 화살표 함수(arrow function)는 선택이 아닌 필수">Next Post &rarr;</a></li></ul><div class="comment"><div id="disqus_thread" class="disqus-thread"></div></div></div><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 sidebar-container"><section><h5><a href="/tags/">FEATURED TAGS</a></h5><div class="tags"><a class="tag" href="/tags/#javascript" title="javascript">javascript</a> <a class="tag" href="/tags/#task" title="task">task</a> <a class="tag" href="/tags/#microtask" title="microtask">microtask</a> <a class="tag" href="/tags/#Promise" title="Promise">Promise</a></div></section></div></div></div></article><script type="text/javascript">var disqus_shortname="bonogithub",disqus_identifier="http://blueshw.github.io/2018/01/28/tasks-microtasks-queues-and-schedules/",disqus_url="http://blueshw.github.io/2018/01/28/tasks-microtasks-queues-and-schedules/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a target="_blank" href="https://twitter.com/blueshw" rel="external nofollow noopener noreferrer"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-twitter fa-stack-1x fa-inverse"></i></span></a></li><li><a target="_blank" href="https://www.facebook.com/blueshw" rel="external nofollow noopener noreferrer"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-facebook fa-stack-1x fa-inverse"></i></span></a></li><li><a target="_blank" href="https://github.com/blueshw" rel="external nofollow noopener noreferrer"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 보노의 블로그 2018</p></div></div></div></footer><script src="/js/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/hux-blog.min.js"></script><script>function async(e,n){var t=document,a="script",r=t.createElement(a),c=t.getElementsByTagName(a)[0];r.src=e,n&&r.addEventListener("load",function(e){n(null,e)},!1),c.parentNode.insertBefore(r,c)}</script><script>0!==$("#tag_cloud").length&&async("http://blueshw.github.io/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js",function(){var c=document.querySelector("nav");c&&FastClick.attach(c)})</script><script>var _gaId="UA-50048807-2",_gaDomain="blueshw.github.io";!function(a,e,g,n,t,o,c){a.GoogleAnalyticsObject="ga",a.ga=a.ga||function(){(a.ga.q=a.ga.q||[]).push(arguments)},a.ga.l=1*new Date,o=e.createElement(g),c=e.getElementsByTagName(g)[0],o.async=1,o.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(o,c)}(window,document,"script"),ga("create",_gaId,_gaDomain),ga("send","pageview")</script><img src="http://blueshw.github.io/img/icon_wechat.png" width="0" height="0"></body></html>