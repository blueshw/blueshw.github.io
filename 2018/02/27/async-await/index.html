<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="R3ZeY1PmaJUY9j_cgNABjesJFgHWVCJpb4TsdfXntMA"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content=""><meta name="keyword" content=""><link rel="shortcut icon" href="/img/favicon2.ico"><link rel="canonical" href="http://blueshw.github.io/2018/02/27/async-await/"><title>[javascript] async, await를 사용하여 비동기 javascript를 동기식으로 만들자 - 보노의블로그 | Bono&#39;s Blog</title><link rel="canonical" href="http://blueshw.github.io/2018/02/27/async-await/"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/hux-blog.css?v=20180409"><link rel="stylesheet" href="/css/highlight.css"><link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]--><script></script></head><body ontouchstart=""><nav class="navbar navbar-default navbar-fixed-top"><div class="container-fluid"><div class="navbar-header page-scroll"><button type="button" class="navbar-toggle"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand" href="/">보노의 블로그</a></div><div id="huxblog_navbar"><div class="navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="/">Home</a></li><li><a href="/about/">About</a></li><li><a href="/archives/">Archives</a></li><li><a href="/tags/">Tags</a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");function handleMagic(e){0<$navbar.className.indexOf("in")?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}$toggle.addEventListener("click",handleMagic)</script><style type="text/css"></style><header class="intro-header"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-heading"><div class="tags"><a class="tag" href="/tags/#javascript" title="javascript">javascript</a> <a class="tag" href="/tags/#ES8" title="ES8">ES8</a> <a class="tag" href="/tags/#setTimeout" title="setTimeout">setTimeout</a> <a class="tag" href="/tags/#promise" title="promise">promise</a> <a class="tag" href="/tags/#callback" title="callback">callback</a> <a class="tag" href="/tags/#async &amp; await" title="async &amp; await">async &amp; await</a> <a class="tag" href="/tags/#이터레이터" title="이터레이터">이터레이터</a> <a class="tag" href="/tags/#제너레이터" title="제너레이터">제너레이터</a></div><h1>[javascript] async, await를 사용하여 비동기 javascript를 동기식으로 만들자</h1><h2 class="subheading"></h2><span class="meta">Posted by bono on 2018-02-27</span></div></div></div></div></header><article><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container"><p>async, await는 ES8(ECMAScript2017)의 공식 스펙(<a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/async_function" rel="external nofollow noopener noreferrer" target="_blank">링크</a>)으로 비교적 최근에 정의된 문법입니다. <code>async, await</code>를 사용하면 비동기 코드를 작성할 때 비교적 쉽고 명확하게 코드를 작성할 수 있습니다. 자바스크립트는 싱글 스레드 프로그래밍언어기 때문에 비동기처리가 필수적입니다. 비동기 처리는 그 결과가 언제 반환될지 알수 없기 때문에 동기식으로 처리하는 기법들이 사용되어야 합니다. 대표적으로 <code>setTimeout</code>이 있고 <code>callback</code>과 <code>promise</code>가 있습니다. 세 가지 모두 비동기 코드를 동기식으로 작성하는데 훌륭한 기법들이지만, 모두 약간의 문제점을 가지고 있습니다. async와 await는 이런 문제들을 해결함과 동시에 그 사용법에 있어서도 훨씬 단순해졌습니다. 각각의 방식들을 살펴본 뒤 async, await를 어떻게 사용하고 어떤 방식으로 구현되어 있는지 알아보도록 하겠습니다.</p><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p>setTimeout은 특정 시간 동안 기다렸다가 이후 첫번째 파라미터의 함수를 실행하는 방식을 사용합니다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> first = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> second = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  result = add(first, second);</span><br><span class="line">  <span class="built_in">console</span>.log(result); <span class="comment">// 30</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>위 코드는 1초 후에 10과 20을 더해서 result에 30을 할당하는 간단한 setTimeout 예제입니다. setTimeout 함수의 첫번째 파라미터는 실행될 함수이고, 두번째 파라미터는 첫번째 파라미터가 얼마후(ms)에 실행될지를 결정합니다. 여기에 별 문제는 없어 보이지만 비동기에 대한 이해가 부족한 상황에서 더 복잡한 코드를 작성하다가는 큰 문제에 부딪칠수도 있습니다. 조금 수정된 코드입니다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> first = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> second = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  result = add(first, second);</span><br><span class="line">  <span class="built_in">console</span>.log(result); <span class="comment">// 40</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">first = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>이 코드가 동기식으로 처리된다면 result가 30이겠지만, 실제로 console에 찍히는 값은 40입니다. 어디가 잘못 되었을까요?</p><p>자바스크립트는 각각의 <code>task</code>를 큐에 적재해두고 순서대로 처리합니다. 이 때 어떤 코드가 새로운 태스크로 적재되지에 대한 이해가 부족하면 위와 같은 실수를 저지를 수 있습니다. 최초의 task는 스크립트 파일 자체입니다. 이 첫번째 task 내에 <code>setTimeout은 별도의 task를 생성</code>하고 첫번째 task가 종료되길 기다립니다. 첫번째 task인 스크립트의 실행이 끝나면 비로소 setTimeout의 함수를 실행할 준비를 합니다. 즉 first의 값은 초기에 10이였지만 첫번째 스크립트가 종료되면 20이 되기때문에 결과적으로 result는 40이 됩니다. task에 대한 이해가 부족하다면 지난번에 번역했던 <a href="https://blueshw.github.io/2018/01/28/tasks-microtasks-queues-and-schedules/">Tasks, microtasks, queues and schedules</a><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" rel="external nofollow noopener noreferrer" target="_blank">(원본)</a>를 참고하세요.</p><p>그럼 이 코드를 동기식으로 처리하려면 어떻게 해야할까요?</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> first = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> second = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getResult</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    result = add(first, second);</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// 30</span></span><br><span class="line">    callback();</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getResult(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  first = <span class="number">20</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>위와 같이 callback 함수를 사용하면 비동기 코드를 동기식으로 작성할 수 있습니다. 그렇다면 이제 비동기 코드를 동기식으로 바꾸기 위해 사용하는 callback이 무엇이고 어떻게 사용하는지 알아보도록 하겠습니다.</p><h3 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h3><p>callback 함수란 호출하는 함수(calling function)가 호출되는 함수(called 함수)로 전달하는 함수를 말하며 이때 callback 함수의 제어권은 호출되는 함수에게 있습니다. callback 함수는 setTimeout 함수와 같은 비동기 코드를 동기식으로 처리하기 위해 사용합니다. production에 사용되는 코드에서는 보통 네트워크 요청 등의 비동기 코드에 많이 사용됩니다.</p><p>callback이 직관적(하나만 사용했을 때)이고 이해가 어렵지는 않지만, 여러개의 callback을 연달아 사용하게 되면 에러가 발생할 가능성이 높고, 코드의 가독성도 크게 떨어지게 됩니다.<br></p><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 각 함수는 비동기로 처리되는 로직이라 가정합니다</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goWork</span><span class="params">(time1, timeStartWork)</span> </span>&#123;</span><br><span class="line">  wakeUp(time1, <span class="function"><span class="keyword">function</span> <span class="params">(time2)</span> </span>&#123;</span><br><span class="line">    takeSubway(time2, <span class="function"><span class="keyword">function</span><span class="params">(time3)</span> </span>&#123;</span><br><span class="line">      takeOffSubway(time3, <span class="function"><span class="keyword">function</span><span class="params">(time4)</span> </span>&#123;</span><br><span class="line">        arriveWork(time4, <span class="function"><span class="keyword">function</span><span class="params">(arrivalTime)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (arrivalTime &gt; timeStartWork) &#123;</span><br><span class="line">            fire();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>callback은 비동기 코드를 동기적 만드는데 확실한 방법이긴 하지만 남발하게 되면 가독성이 크게 떨어지고 코드의 복잡성도 크게 증가하게 됩니다. 또한 callback의 호출에 대한 제어권이 다른 함수들에게 넘어가 버리기 때문에 각 콜백함수가 언제 어떻게 몇번 실행되는지 확신을 할 수 없습니다. 이렇게 코드를 작성하면(물론 잘 하면 상관없지만), 특히 여러명이서 코드를 공유하는 경우라면 결과를 예측하기 어려울 뿐 아니라 코드내에서 에러가 발생할 확률도 높아집니다.</p><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>promise는 약속입니다. 어떤 작업이 성공했을 때(resolve), promise 객체의 then() 함수에 넘겨진 파라미터(함수)를 단 한번만 호출하겠다는 약속입니다. callback의 경우 제어권이 호출되는 함수로 넘어가 버리기 때문에 신뢰성이 다소 떨어지지만 promise는 함수 실행이 성공했을때 then() 함수의 파라미터(함수)가 단 한번만 호출되기 때문에 함수를 호출하는 입장에서 확신을 가지고 코드를 작성할 수 있습니다. 또한 실패했을 경우(reject)에도 catch()함수를 통해서 실패 이후의 작업을 처리할 수 있습니다. 위의 함수(goWork)를 promise로 바꾸어보겠습니다.<br></p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goWork</span><span class="params">(time1, timeStartWork)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> wakeUp(time1).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(time2)</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> tackSubway(time2);</span><br><span class="line">    &#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(time3)</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> takeOffSubway(time3); </span><br><span class="line">    &#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(time4)</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> arriveWork(time4) &#123;</span><br><span class="line">    &#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(arrivalTime)</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (arrivalTime &gt; timeStartWork) &#123;</span><br><span class="line">        fire();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>callback보다는 훨씬 덜 복잡해 보입니다. 여기에다 ES6의 arrow function 문법을 적용하면 훨씬 더 간단해집니다.<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goWork</span>(<span class="params">time1, timeStartWork</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> wakeUp(time1)</span><br><span class="line">    .then(<span class="function"><span class="params">time2</span> =&gt;</span> tackSubway(time2))</span><br><span class="line">    .then(<span class="function"><span class="params">time3</span> =&gt;</span> takeOffSubway(time3))</span><br><span class="line">    .then(<span class="function"><span class="params">time4</span> =&gt;</span> arriveWork(time4))</span><br><span class="line">    .then(<span class="function"><span class="params">arrivalTime</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (arrivalTime &gt; timeStartWork) &#123;</span><br><span class="line">        fire();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>promise는 충분히 깔끔하고 완성되어 보이지만, 사실 완전히 만족스럽지 않습니다. C나 Java와 같은 절차적 언어에서 사용하듯이 단순하고 직관적이면 더 좋겠다는 생각이 드네요.<br>그럼 이제 async와 await가 등장해야할 시간입니다.</p><h3 id="async-amp-await"><a href="#async-amp-await" class="headerlink" title="async &amp; await"></a>async &amp; await</h3><p>async와 await는 절차적 언어에서 작성하는 코드와 같이 사용법도 간단하고 이해하기도 쉽습니다. function 키워드 앞에 <code>async</code>만 붙여주면 되고 비동기로 처리되는 부분 앞에 <code>await</code>만 붙여주면 됩니다. 다만, 몇 가지 주의할 점이 있다면 await 뒷부분이 반드시 promise를 반환해야 한다는 것과 async function 자체도 promise를 반환한다는 것입니다. 그럼 사용법을 먼저 살펴보겠습니다.<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">goWork</span>(<span class="params">time1, timeStartWork</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> time2 = <span class="keyword">await</span> wakeUp(time1);</span><br><span class="line">  <span class="keyword">const</span> time3 = <span class="keyword">await</span> takeSubway(time2);</span><br><span class="line">  <span class="keyword">const</span> time4 = <span class="keyword">await</span> takeOffSubway(time3);</span><br><span class="line">  <span class="keyword">const</span> arrivalTime = <span class="keyword">await</span> arriveWork(time4);</span><br><span class="line">  <span class="keyword">if</span> (arrivalTime &gt; timeStartWork) &#123;</span><br><span class="line">    fire();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>우와, promise에 비해 훨씬 직관적입니다. 사용법도 그다지 어렵지 않고 코드 이해도 훨씬 좋아졌습니다. 그렇다면 간단하게 function 앞에 async를 붙여주고 호출하는 함수앞에 await를 붙여준 것만으로 어떻게 비동기 함수들의 동기처리가 가능해진걸까요? async와 await가 어떻게 동작하는지 알아보기 위해 babel의 도움을 좀 받아야겠습니다. async, await는 ES8 스펙이라 몇몇 브라우저에서는 호환되지 않게 때문에(최신 크롬은 됩니다) 기존 브라우저에서 동작하도록 자바스크립트 코드를 변환해 주어야 합니다. <a href="https://babeljs.io/repl/#?babili=false&amp;browsers=&amp;build=&amp;builtIns=false&amp;code_lz=IYZwngdgxgBAZgV2gFwJYHsIwOboOroBOA1gBRoC2ApgIwA0MlVAyssIcgSQJQwDeAKBgwomEMkapqAJhgBeGMADuwVBJXEqAVQAO5KbW4BuISLESmAZnmKVaxsE3MEAIxVh9M46dERxk6gAWG2VVC0cqAHk4OGc3YA8rb2Fff3ZCVAA3YAAbABUDELsJdKyqLjImQOSYVDgYUlLs_MKAPgCWNg4K3kFhYThUQipSGoBfATGgA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=false&amp;fileSize=false&amp;lineWrap=true&amp;presets=es2015%2Creact%2Cstage-2&amp;prettier=true&amp;targets=&amp;version=6.26.0&amp;envVersion=" rel="external nofollow noopener noreferrer" target="_blank">babel 변환 코드</a>.</p><p>두 부분으로 나누어 간단히 살펴보겠습니다.<br>(아래 설명들은 정리가 잘 안되있어 이해하기 어렵습니다. 설명을 잘 못하는거 보니 아직 저도 잘 이해 못하고 있는 부분이 있는것 같네요ㅠㅠ)<br></p><figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> goWork = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _ref = _asyncToGenerator(</span><br><span class="line">    regeneratorRuntime.mark(<span class="function"><span class="keyword">function</span> <span class="title">_callee</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      time1,</span></span></span><br><span class="line"><span class="function"><span class="params">      timeStartWork</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> time2, time3, time4, arrivalTime;</span><br><span class="line">      <span class="keyword">return</span> regeneratorRuntime.wrap(</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">_callee$</span>(<span class="params">_context</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> ((_context.prev = _context.next)) &#123;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                _context.next = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> wakeUp(time1);</span><br><span class="line">              <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                time2 = _context.sent;</span><br><span class="line">                _context.next = <span class="number">5</span>;</span><br><span class="line">                <span class="keyword">return</span> takeSubway(time2);</span><br><span class="line">              ...</span><br><span class="line">              <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">              <span class="keyword">case</span> <span class="string">"end"</span>:</span><br><span class="line">                <span class="keyword">return</span> _context.stop();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        _callee,</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line">      );</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">goWork</span>(<span class="params">_x, _x2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _ref.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p></p><p>첫번째로 위쪽의 코드는 goWork를 즉시 실행하는 함수입니다. 즉시실해함수기 때문에 선언과 동시에 함수가 실행됩니다. 이 함수의 결과값은(<code>var goWork</code>에 할당되는 값) 맨 아래의 <code>goWork(_x, _x2)</code> 함수입니다. 즉, 외부에서 <code>goWork(...)</code>를 호출하면 맨 아래의 goWork 함수가 호출되는것입니다.</p><p>외부에서 goWork를 호출하면 <code>_ref</code>가 실행되는데 _ref는 <code>_asyncToGenerator</code> 함수가 실행된 결과(이 또한 함수)가 할당됩니다. <code>_asyncToGenerator</code> 함수는 하나의 인자(함수)를 가지는데, 이 인자는 실행되면서 내부적으로 제너레이터가 생성합니다. 이 제너레이터를 생성하고 동작을 처리하기 위해서 babel의 <a href="https://babeljs.io/docs/plugins/transform-regenerator/" rel="external nofollow noopener noreferrer" target="_blank">regeneratorRuntime</a> 플러그인이 이용됩니다.</p><p>제너레이터가 생성되어 실행되면 이터레이터가 만들어지고 이터레이터의 next 함수로 yield 구문의 코드를 차례차례 실행하는게 보통의 제너레이터 구조입니다. 여기에서는 만들어진 이터레이터의 next 함수(step(‘next’))가 호출될 때 마다 context의 위치를 변경하고(context.next), 해당 위치의 함수를 실행합니다. (실제 await 부분).</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_asyncToGenerator</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> gen = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">key, arg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> info = gen[key](arg);</span><br><span class="line">          <span class="keyword">var</span> value = info.value;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (info.done) &#123;</span><br><span class="line">          resolve(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(value).then(</span><br><span class="line">            <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">              step(<span class="string">"next"</span>, value);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">              step(<span class="string">"throw"</span>, err);</span><br><span class="line">            &#125;</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> step(<span class="string">"next"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>두번째 부분입니다. 여기서는 우선 위에서 보았던 제너레이터 처리 함수인 <code>fn</code>을 실행시켜서 이터레이터(변수명은 gen이지만 이터레이터가 맞는듯)를 만들어 두고 그 아래에서 <code>프로미스</code>를 리턴합니다. <code>프로미스</code>가 리턴된다는 것은 goWork() 함수의 리턴 타입이 Promise가 된다는 것입니다(코드를 잘 따라가보면 goWork()의 결과값이 Promise를 리턴하는 부분임을 알 수 있습니다). 프로미스 내부에는 <code>step</code>이라는 함수를 만들고 이 함수를 <code>next</code> 인자와 함께 호출합니다. step에서는 인자로 받은 <code>key</code>를 이용하여 <code>gen[key](arg)</code> 형태로 함수를 호출합니다. 이때 key가 <code>next</code>라면 이터레이터의 next()와 동일한 함수가 호출될것이고 반환값(info)은 당연히 <code>{value: xxx, done: false}</code>가 될 것입니다. info.done이 <code>true</code>일때는 제너레이터가 종료된것이므로 resolve()를 호출합니다. 그리고 <code>false</code>인 경우에는 새로운 프로미스를 생성하고 next함수를 실행합니다.</p><p>위의 부분과 연관지어 설명하자면, step()함수가 한 번 실행될때 마다 하나의 프로미스가 생성되고, 제너레이터의 context 위치가 변경되고 해당부분의 함수를 호출합니다.</p><p>async와 await는 제너레이터 구조와 거의 동일합니다. 제너레이터에서 함수옆에 붙이는 ‘*’ 대신 async를 붙이고, yield 대신 await를 사용합니다. 다만 await 함수에서는 이터레이터의 next() 호출을 프로미스의 resolve()함수가 담당합니다. 그렇기 때문에 await 함수(프로미스)가 성공(resolve)해야지만 함수의 결과값을 리턴해줄 수 있게됩니다. 이를 간단히 요약해보면 <code>async,await =&gt; 제너레이터,이터레이터 + 프로미스</code>라 할 수 있겠습니다.</p><p>이상 자바스크립트의 비동기 함수들과 동기식 처리의 발전과정에 대해 알아봤습니다. 개인의 공부 및 정리를 목적으로 작성한 글이라 전문성이 결여되어 있으며 다소 이해하기 어려운 설명들이 다수 포함되어 있습니다.</p><h3 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h3><ul><li><a href="https://medium.com/@_bengarrison/javascript-es8-introducing-async-await-functions-7a471ec7de8a" rel="external nofollow noopener noreferrer" target="_blank">https://medium.com/@_bengarrison/javascript-es8-introducing-async-await-functions-7a471ec7de8a</a></li><li><a href="https://hyunseob.github.io/2015/08/09/async-javascript/" rel="external nofollow noopener noreferrer" target="_blank">https://hyunseob.github.io/2015/08/09/async-javascript/</a></li><li><a href="http://meetup.toast.com/posts/73" rel="external nofollow noopener noreferrer" target="_blank">http://meetup.toast.com/posts/73</a></li><li><a href="https://jicjjang.github.io/2017/02/05/promise-and-async-await/" rel="external nofollow noopener noreferrer" target="_blank">https://jicjjang.github.io/2017/02/05/promise-and-async-await/</a></li><li><a href="https://medium.com/@jooyunghan/babel%EC%9D%80-generator%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%B0%94%EA%BE%B8%EB%82%98-c78523645cd7" rel="external nofollow noopener noreferrer" target="_blank">https://medium.com/@jooyunghan/babel%EC%9D%80-generator%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%B0%94%EA%BE%B8%EB%82%98-c78523645cd7</a></li></ul><hr><ul class="pager"><li class="previous"><a href="/2018/03/12/this/" data-toggle="tooltip" data-placement="top" title="[javascript] this는 어렵지 않습니다.">&larr; Previous Post</a></li><li class="next"><a href="/2018/01/28/tasks-microtasks-queues-and-schedules/" data-toggle="tooltip" data-placement="top" title="[번역] Tasks, microtasks, queues and schedules">Next Post &rarr;</a></li></ul><div class="comment"><div id="disqus_thread" class="disqus-thread"></div></div></div><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 sidebar-container"><section><h5><a href="/tags/">FEATURED TAGS</a></h5><div class="tags"><a class="tag" href="/tags/#javascript" title="javascript">javascript</a> <a class="tag" href="/tags/#ES8" title="ES8">ES8</a> <a class="tag" href="/tags/#setTimeout" title="setTimeout">setTimeout</a> <a class="tag" href="/tags/#promise" title="promise">promise</a> <a class="tag" href="/tags/#callback" title="callback">callback</a> <a class="tag" href="/tags/#async &amp; await" title="async &amp; await">async &amp; await</a> <a class="tag" href="/tags/#이터레이터" title="이터레이터">이터레이터</a> <a class="tag" href="/tags/#제너레이터" title="제너레이터">제너레이터</a></div></section></div></div></div></article><script type="text/javascript">var disqus_shortname="bonogithub",disqus_identifier="http://blueshw.github.io/2018/02/27/async-await/",disqus_url="http://blueshw.github.io/2018/02/27/async-await/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a target="_blank" href="https://twitter.com/blueshw" rel="external nofollow noopener noreferrer"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-twitter fa-stack-1x fa-inverse"></i></span></a></li><li><a target="_blank" href="https://www.facebook.com/blueshw" rel="external nofollow noopener noreferrer"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-facebook fa-stack-1x fa-inverse"></i></span></a></li><li><a target="_blank" href="https://github.com/blueshw" rel="external nofollow noopener noreferrer"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 보노의 블로그 2018</p></div></div></div></footer><script src="/js/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/hux-blog.min.js"></script><script>function async(e,n){var t=document,a="script",r=t.createElement(a),c=t.getElementsByTagName(a)[0];r.src=e,n&&r.addEventListener("load",function(e){n(null,e)},!1),c.parentNode.insertBefore(r,c)}</script><script>0!==$("#tag_cloud").length&&async("http://blueshw.github.io/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js",function(){var c=document.querySelector("nav");c&&FastClick.attach(c)})</script><script>var _gaId="UA-50048807-2",_gaDomain="blueshw.github.io";!function(a,e,g,n,t,o,c){a.GoogleAnalyticsObject="ga",a.ga=a.ga||function(){(a.ga.q=a.ga.q||[]).push(arguments)},a.ga.l=1*new Date,o=e.createElement(g),c=e.getElementsByTagName(g)[0],o.async=1,o.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(o,c)}(window,document,"script"),ga("create",_gaId,_gaDomain),ga("send","pageview")</script><img src="http://blueshw.github.io/img/icon_wechat.png" width="0" height="0"></body></html>