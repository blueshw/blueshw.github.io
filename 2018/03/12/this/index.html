<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="R3ZeY1PmaJUY9j_cgNABjesJFgHWVCJpb4TsdfXntMA"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content=""><meta name="keyword" content=""><link rel="shortcut icon" href="/img/favicon2.ico"><link rel="canonical" href="http://blueshw.github.io/2018/03/12/this/"><title>[javascript] this는 어렵지 않습니다. - 보노의블로그 | Bono&#39;s Blog</title><link rel="canonical" href="http://blueshw.github.io/2018/03/12/this/"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/hux-blog.css"><link rel="stylesheet" href="/css/highlight.css"><link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]--><script></script></head><body ontouchstart=""><nav class="navbar navbar-default navbar-fixed-top"><div class="container-fluid"><div class="navbar-header page-scroll"><button type="button" class="navbar-toggle"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand" href="/">보노의 블로그</a></div><div id="huxblog_navbar"><div class="navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="/">Home</a></li><li><a href="/about/">About</a></li><li><a href="/archives/">Archives</a></li><li><a href="/tags/">Tags</a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");function handleMagic(e){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}$toggle.addEventListener("click",handleMagic)</script><style type="text/css"></style><header class="intro-header"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-heading"><div class="tags"><a class="tag" href="/tags/#javascript" title="javascript">javascript</a> <a class="tag" href="/tags/#bind" title="bind">bind</a> <a class="tag" href="/tags/#this" title="this">this</a> <a class="tag" href="/tags/#arrow function" title="arrow function">arrow function</a> <a class="tag" href="/tags/#subroutine" title="subroutine">subroutine</a></div><h1>[javascript] this는 어렵지 않습니다.</h1><h2 class="subheading"></h2><span class="meta">Posted by bono on 2018-03-12</span></div></div></div></div></header><article><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container"><p>this는 어렵지 않습니다.</p><p>this를 어렴풋이 알고는 있지만, 누가 물어봤을때 제대로 대답해 줄수 있도록 정리해보겠습니다. 많은 개발자들이 javascript의 this를 혼란스러워합니다. 사실 개념 자체가 어렵진 않습니다. 다만, 다른 프로그래밍 언어들과 사용법에 차이가 있을 뿐이죠. 언어마다 조금은 차이가 있겠지만 대표적으로 JAVA같은 객체지향 언어에서의 this는 클래스 인스턴스의 레퍼런스 변수입니다. 하지만 javascript에서 this는 전혀 다른 의미를 가집니다. 개발을 시작하고 처음으로 javascript를 접한 개발자라면 조금 덜 혼란스러울지도 모르겠지만, 많은 개발자들이 C, C++, Java, python 등의 언어를 먼저 배운 뒤 javascript를 접하는 케이스가 많습니다. 또한, Jquery 등의 라이브러리에 의존하는 경향 때문에 언어 자체의 문법이나 특성의 이해보다는 사용법만 습득하기도 하죠. 이런 경우, javascript의 this가 충분히 혼란스러울수 있을것 같습니다.</p><h3 id="this는-현재-실행-문맥이다"><a href="#this는-현재-실행-문맥이다" class="headerlink" title="this는 현재 실행 문맥이다"></a>this는 현재 실행 문맥이다</h3><p><code>실행문맥</code>이란 말은 호출자가 누구냐는 것과 같습니다.<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// true, 호출자는 window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> caller = &#123;</span><br><span class="line">  f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span> === <span class="built_in">window</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">caller.f(); <span class="comment">// false, 호출자는 caller 객체</span></span><br></pre></td></tr></table></figure><p></p>
<p>첫번째는 함수 호출, 두번째는 메소드 호출이라고 말하는데 이런 구분이 괜한 혼란을 야기합니다. 첫번째 alert도 따지고보면 <code>window.alert()</code>과 동일하기 때문에 window 객체의 메소드 호출이라봐도 무방합니다. 다만, <code>strict-mode</code>에서는 전역 객체냐 일반 객체냐에 따라 함수내부에 this의 결과가 다르다는 차이는 있죠. 그러나 이 문제 또한 window를 함수 호출 앞에 붙여주면 해결됩니다.<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonStrictMode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strictMode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(nonStrictMode()); <span class="comment">// window</span></span><br><span class="line"><span class="built_in">console</span>.log(strictMode()); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.stricMode()); <span class="comment">// window</span></span><br></pre></td></tr></table></figure><p></p>
<h3 id="생성자-함수-객체에서는-어떻게-쓰이나"><a href="#생성자-함수-객체에서는-어떻게-쓰이나" class="headerlink" title="생성자 함수 / 객체에서는 어떻게 쓰이나?"></a>생성자 함수 / 객체에서는 어떻게 쓰이나?</h3><p>생성자는 new로 객체를 만들어 사용하는 방식입니다. 객체지향 언어에서 일반적으로 객체를 만들 때 쓰이는 문법과 동일하죠. 가리키는 대상 또한 객체지향 언어의 <code>this</code>와 같기 때문에 이해하기가 한결 수월합니다.<br></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NewObject</span></span>(name, color) &#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.color = color;</span><br><span class="line">  <span class="built_in">this</span>.isWindow = <span class="function"><span class="keyword">function</span></span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span> === window;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const <span class="keyword">new</span><span class="type">Obj</span> = <span class="keyword">new</span> <span class="type">NewObject</span>(<span class="string">'nana'</span>, <span class="string">'yellow'</span>);</span><br><span class="line">console.log(<span class="keyword">new</span><span class="type">Obj</span>.name); <span class="comment">// nana</span></span><br><span class="line">console.log(<span class="keyword">new</span><span class="type">Obj</span>.color); <span class="comment">// yellow</span></span><br><span class="line">console.log(<span class="keyword">new</span><span class="type">Obj</span>.isWindow()); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">const <span class="keyword">new</span><span class="type">Obj2</span> = <span class="keyword">new</span> <span class="type">NewObject</span>(<span class="string">'didi'</span>, <span class="string">'red'</span>);</span><br><span class="line">console.log(<span class="keyword">new</span><span class="type">Obj2</span>.name); <span class="comment">// didi</span></span><br><span class="line">console.log(<span class="keyword">new</span><span class="type">Obj2</span>.color); <span class="comment">// red</span></span><br><span class="line">console.log(<span class="keyword">new</span><span class="type">Obj2</span>.isWindow()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p></p>
<p>new 키워드로 새로운 객체를 생성했을 경우 생성자 함수 내의 this는 new를 통해 만들어진 새로운 변수가 됩니다. <code>newObj</code>, <code>newObj2</code>는 같은 생성자 함수로 만들어진 객체이지만 완전히 별도의 객체이기 때문에 각 객체의 속성들은 서로 관련이 없습니다. 만약 new 키워드를 빼먹으면 어떻게 될까요?<br></p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> withoutNew = NewObject(<span class="string">'nana'</span>, <span class="string">'yellow'</span>);</span><br><span class="line">console.<span class="built_in">log</span>(withoutNew.name); <span class="comment">// error</span></span><br><span class="line">console.<span class="built_in">log</span>(withoutNew.<span class="built_in">color</span>); <span class="comment">// error</span></span><br><span class="line">console.<span class="built_in">log</span>(withoutNew.isWindow()); <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p></p>
<p>new 키워드가 없으면 일반적인 함수 실행과 동일하게 동작하므로, <code>NewObject</code> 함수내의 this는 <code>window</code> 객체가 됩니다. 하지만 <code>withoutNew</code>가 함수 실행의 결과값이 할당되므로 각 property를 가져올 수 없습니다.<br>그렇다면, 생성자 함수가 아닌 일반 객체에서는 어떨까요?<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'john'</span>,</span><br><span class="line">  age: <span class="number">15000</span>,</span><br><span class="line">  nickname: <span class="string">'man from earth'</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// john</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> otherPerson = person;</span><br><span class="line">otherPerson.name = <span class="string">'chris'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// chris</span></span><br><span class="line"><span class="built_in">console</span>.log(otherPerson.getName()); <span class="comment">// chris</span></span><br></pre></td></tr></table></figure><p></p>
<p>생성자 함수와 크게 다르지 않습니다. 한가지 눈여겨 볼 점은 <code>otherPerson.name</code>을 <code>chris</code>로 설정한 뒤 person.getName() 호출하면 그 결과는 <code>chris</code>입니다. 그 이유는 otherPerson은 person의 레퍼런스 변수이므로 하나(otherPerson)를 변경하면 다른 하나(person)도 변경됩니다. 이를 피하기 위해서는 <code>Object.assign()</code>메서드(ES6 지원)를 이용하여 완전히 별도의 객체로 만들어야 합니다.<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'john'</span>,</span><br><span class="line">  age: <span class="number">15000</span>,</span><br><span class="line">  nickname: <span class="string">'man from earth'</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newPerson = <span class="built_in">Object</span>.assign(&#123;&#125;, person);</span><br><span class="line">newPerson.name = <span class="string">'chris'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// john</span></span><br><span class="line"><span class="built_in">console</span>.log(newPerson.getName()); <span class="comment">// chris</span></span><br></pre></td></tr></table></figure><p></p>
<h3 id="bind-arrow-function"><a href="#bind-arrow-function" class="headerlink" title="bind, arrow function"></a>bind, arrow function</h3><p>이번에는 생성자 함수 안에서 또 다른 함수가 있는 경우를 살펴보겠습니다.<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Family</span>(<span class="params">firstName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">  <span class="keyword">const</span> names = [<span class="string">'bill'</span>, <span class="string">'mark'</span>, <span class="string">'steve'</span>];</span><br><span class="line">  names.map(<span class="function"><span class="keyword">function</span>(<span class="params">lastName, index</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(lastName + <span class="string">' '</span> + <span class="keyword">this</span>.firstName);   </span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>);      </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> kims = <span class="keyword">new</span> Family(<span class="string">'kim'</span>);</span><br><span class="line"><span class="comment">// bill undefined</span></span><br><span class="line"><span class="comment">// window</span></span><br><span class="line"><span class="comment">// mark undefined</span></span><br><span class="line"><span class="comment">// window</span></span><br><span class="line"><span class="comment">// steve undefined</span></span><br><span class="line"><span class="comment">// window</span></span><br></pre></td></tr></table></figure><p></p>
<p><code>Family</code>라는 생성자 함수 안에서 <code>map</code> 메서드를 호출합니다. map 메서드의 인자는 value와 index를 인자로 가지는 새로운 함수입니다. 이를 <code>서브루틴</code>이라 부르겠습니다. 서브루틴이 특별히 다른 개념은 아닙니다. 자바스크립트에서 함수의 의미가 다양하기 때문에 단지 메서드가 아닌 함수와 구분하기 위한 용도로 서브루틴이라는 단어를 사용합니다. </p>
<p>이 서브루틴에서는 lastName들을 담은 <code>names</code> 배열의 map 메서드를 이용하여 lastName과 this의 firstName을 같이 출력하고자 합니다. 하지만 막상 실행을 해보면 예상과 다르게 출력됩니다. kim이 출력될 위치에 <code>undefined</code>가 출력되었습나다. 이는 map의 서브루틴에서 this를 사용하는 것이 문제였습니다. this가 실행 문맥이라고 했던것을 상기해보면 undefined가 출력되는 이유를 짐작해볼 수 있습니다. map 메서드의 서브루틴은 호출될때 map의 context(this)로 바인드 되지 않습니다. 바인드 되지 않았다는 것은 실행문맥이 전역이라는 것이고 실행문맥이 전역이란 말은 (비엄격모드에서) 서브루틴 내 this가 <code>window</code>라는 것입니다.</p>
<p>비슷한 현상을 다른 예제에서 살펴보겠습니다. 아래 함수를 실행시키면 innerFunc안의 this는 window가 출력됩니다.<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testObj = &#123;</span><br><span class="line">  outerFunc:  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window</span></span><br><span class="line">    &#125;</span><br><span class="line">    innerFunc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">testObj.outerFunc();</span><br></pre></td></tr></table></figure><p></p>
<p>outherFunc가 외부에서 실행(testObj.outerFunc())되면 this는 testObj입니다. 그리고 outerFunc 내부에서 innerFunc가 호출할때는 그 어떤 문맥도 지정하지(바인드되지) 않았습니다. 전역 context(window)에서 실행되었다는 것이죠. 이게 바로 (비엄격모드에서) innerFunc의 this가 window가 되는 이유 입니다.</p>
<p>다시 이전의 생성자 함수(Family)로 돌아갑니다. map 메서드의 서브루틴에서 this가 window가 된다는 것은 위에서 이미 설명했습니다. 하지만, 생성자 함수 내의 특정 변수를 서브루틴 내에서 사용할 수도 있습니다. 이 때, 실행문맥(this)을 Family로 지정하려면 간단하게는 별도의 상수(const)를 지정하면 됩니다.<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Family</span>(<span class="params">firstName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    <span class="keyword">const</span> names = [<span class="string">'bill'</span>, <span class="string">'mark'</span>, <span class="string">'steve'</span>];</span><br><span class="line">    <span class="keyword">const</span> that = <span class="keyword">this</span>;</span><br><span class="line">    names.map(<span class="function"><span class="keyword">function</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value + <span class="string">' '</span> + that.firstName); </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> kims = <span class="keyword">new</span> Family(<span class="string">'kim'</span>);</span><br><span class="line"><span class="comment">// bill kim</span></span><br><span class="line"><span class="comment">// mark kim</span></span><br><span class="line"><span class="comment">// steve kim</span></span><br></pre></td></tr></table></figure><p></p>
<p>문제 없이 이름들이 출력됩니다. 하지만, 항상 <code>that</code>이라는 상수를 만들어주면 귀찮습니다. 또한, 만에 하나 실수로 빼먹기라도 하면 어마어마한 문제가 발생할지도 모릅니다. 혹은 서브루틴 안에서 또다른 서브루틴을 사용할 수도 있습니다. 그 때는 <code>anotherThat</code>을 만들어야 할까요? 이 문제를 해결하기 위해서 <code>bind</code>라는 메서드를 사용합니다.<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Family</span>(<span class="params">firstName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    <span class="keyword">const</span> names = [<span class="string">'bill'</span>, <span class="string">'mark'</span>, <span class="string">'steve'</span>];</span><br><span class="line">    names.map(<span class="function"><span class="keyword">function</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value + <span class="string">' '</span> + <span class="keyword">this</span>.firstName); </span><br><span class="line">    &#125;.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> kims = <span class="keyword">new</span> Family(<span class="string">'kim'</span>);</span><br></pre></td></tr></table></figure><p></p>
<p>that을 쓸때보다는 깔끔해졌습니다. 하지만 <code>.bind(this)</code>도 항상 붙여줘야한다는 문제는 여전히 남아 있습니다. 이제 <code>arrow function</code>이 나올때가 된것 같네요.<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Family</span>(<span class="params">firstName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    <span class="keyword">const</span> names = [<span class="string">'bill'</span>, <span class="string">'mark'</span>, <span class="string">'steve'</span>];</span><br><span class="line">    </span><br><span class="line">    names.map(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value + <span class="string">' '</span> + <span class="keyword">this</span>.firstName); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> kims = <span class="keyword">new</span> Family(<span class="string">'kim'</span>);</span><br></pre></td></tr></table></figure><p></p>
<p>이제 that도 없고, bind도 없습니다. 함수의 형태만 바꿔주면 모든게 해결됩니다. 그럼 일반 함수형태에서 arrow 함수를 사용했을때 어떤 차이가 있을까요? arrow 함수 또한 ES6에서만 지원하기 때문에 babel 사이트에서 변환해보겠습니다.<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Family</span>(<span class="params">firstName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">  <span class="keyword">var</span> names = [<span class="string">"bill"</span>, <span class="string">"mark"</span>, <span class="string">"steve"</span>];</span><br><span class="line">  names.map(<span class="function"><span class="keyword">function</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value + <span class="string">" "</span> + _this.firstName);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> kims = <span class="keyword">new</span> Family(<span class="string">"kim"</span>);</span><br></pre></td></tr></table></figure><p></p>
<p>that을 사용했을 때와 동일한 방법으로 트랜스파일 되네요. 미리 내부에서만 사용할 변수 <code>_this</code>를 만들어 두고, this를 할당합니다. 그리고 <code>_this</code>를 사용하여 firstName을 가져옵니다. arrow 함수는 호출 대상에 따라 실행문맥이 결정되는 것이 아닙니다. </p>
<h3 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h3><p>this는 어렵지 않습니다. 하지만, 타 언어와 다른 방식으로 사용되기에 주의해서 사용할 필요가 있습니다. 한가지만 기억하자면, this는 누가 호출했느냐에 따라 결정된다는 것입니다. ES6 문법을 사용하면 this를 사용할때 문제점을 완화할 수 있습니다. 예를들어, 서브루틴 내에서 바깥의 this를 사용하려고 할때는 arrow function을 이용하면 간단하게 해결할 수 있습니다.</p>
<p>참고 자료</p>
<ul>
<li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this" rel="external nofollow noopener noreferrer" target="_blank">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this</a></li>
<li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript" rel="external nofollow noopener noreferrer" target="_blank">https://developer.mozilla.org/ko/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript</a></li>
<li><a href="http://webframeworks.kr/tutorials/translate/explanation-of-this-in-javascript-1/" rel="external nofollow noopener noreferrer" target="_blank">http://webframeworks.kr/tutorials/translate/explanation-of-this-in-javascript-1/</a></li>
<li><a href="https://gomugom.github.io/is-class-only-a-syntactic-sugar/" rel="external nofollow noopener noreferrer" target="_blank">https://gomugom.github.io/is-class-only-a-syntactic-sugar/</a></li>
<li><a href="http://webframeworks.kr/tutorials/translate/arrow-function/" rel="external nofollow noopener noreferrer" target="_blank">http://webframeworks.kr/tutorials/translate/arrow-function/</a></li></ul>

                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2018/03/21/function-test-with-jest/" data-toggle="tooltip" data-placement="top" title="[Jest] mock 함수를 이용하여 함수 호출 테스트 하기">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2018/02/27/async-await/" data-toggle="tooltip" data-placement="top" title="[javascript] async, await를 사용하여 비동기 javascript를 동기식으로 만들자">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                
                
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                
                

            </div>
    
        

    

            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 sidebar-container">

                
                
                <section>
                    
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#javascript" title="javascript">javascript</a>
                        
                          <a class="tag" href="/tags/#bind" title="bind">bind</a>
                        
                          <a class="tag" href="/tags/#this" title="this">this</a>
                        
                          <a class="tag" href="/tags/#arrow function" title="arrow function">arrow function</a>
                        
                          <a class="tag" href="/tags/#subroutine" title="subroutine">subroutine</a>
                        
                    </div>
                </section>
                

                
                
            </div>

        </div>
    </div>
</article>





<script type="text/javascript">var disqus_shortname="bonogithub",disqus_identifier="http://blueshw.github.io/2018/03/12/this/",disqus_url="http://blueshw.github.io/2018/03/12/this/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script>

    
    <footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a target="_blank" href="https://twitter.com/blueshw" rel="external nofollow noopener noreferrer"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-twitter fa-stack-1x fa-inverse"></i></span></a></li><li><a target="_blank" href="https://www.facebook.com/blueshw" rel="external nofollow noopener noreferrer"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-facebook fa-stack-1x fa-inverse"></i></span></a></li><li><a target="_blank" href="https://github.com/blueshw" rel="external nofollow noopener noreferrer"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 보노의 블로그 2018</p></div></div></div></footer><script src="/js/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/hux-blog.min.js"></script><script>function async(e,n){var t=document,a="script",r=t.createElement(a),c=t.getElementsByTagName(a)[0];r.src=e,n&&r.addEventListener("load",function(e){n(null,e)},!1),c.parentNode.insertBefore(r,c)}</script><script>0!==$("#tag_cloud").length&&async("http://blueshw.github.io/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js",function(){var c=document.querySelector("nav");c&&FastClick.attach(c)})</script><script>var _gaId="UA-50048807-2",_gaDomain="blueshw.github.io";!function(a,e,g,n,t,o,c){a.GoogleAnalyticsObject="ga",a.ga=a.ga||function(){(a.ga.q=a.ga.q||[]).push(arguments)},a.ga.l=1*new Date,o=e.createElement(g),c=e.getElementsByTagName(g)[0],o.async=1,o.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(o,c)}(window,document,"script"),ga("create",_gaId,_gaDomain),ga("send","pageview")</script>



<img src="http://blueshw.github.io/img/icon_wechat.png" width="0" height="0"></body></html>