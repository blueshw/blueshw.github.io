<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="R3ZeY1PmaJUY9j_cgNABjesJFgHWVCJpb4TsdfXntMA"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content=""><meta name="keyword" content=""><link rel="shortcut icon" href="/img/favicon2.ico"><link rel="canonical" href="http://blueshw.github.io/2018/04/05/react-v16-3-0/"><title>[react] v16.3.0, 무엇이 바뀌었나? - 보노의블로그 | Bono&#39;s Blog</title><link rel="canonical" href="http://blueshw.github.io/2018/04/05/react-v16-3-0/"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/hux-blog.css?v=20180408"><link rel="stylesheet" href="/css/highlight.css"><link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]--><script></script></head><body ontouchstart=""><nav class="navbar navbar-default navbar-fixed-top"><div class="container-fluid"><div class="navbar-header page-scroll"><button type="button" class="navbar-toggle"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand" href="/">보노의 블로그</a></div><div id="huxblog_navbar"><div class="navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="/">Home</a></li><li><a href="/archives/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="/tags/">Tags</a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");function handleMagic(e){0<$navbar.className.indexOf("in")?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}$toggle.addEventListener("click",handleMagic)</script><style type="text/css"></style><header class="intro-header"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-heading"><div class="tags"><a class="tag" href="/tags/#react" title="react">react</a> <a class="tag" href="/tags/#v16.3.0" title="v16.3.0">v16.3.0</a></div><h1>[react] v16.3.0, 무엇이 바뀌었나?</h1><h2 class="subheading"></h2><span class="meta">Posted by bono on 2018-04-05</span></div></div></div></div></header><article><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container"><p>react v16.3.0 이 릴리즈 되었습니다. 개인적인 생각으로는 가장 큰 변화는 두가지 정도입니다. 첫번째는 몇몇 lifecycle method 가 deprecated 되었습니다. 그리고 새로운 Context API 가 추가되었습니다. 그 외에 몇가지 변화를 요약해보면 아래와 같습니다.</p><blockquote><ul><li>새로운 Context API</li><li>새로운 Refs API</li><li>lifecycle 메서드 변경</li><li>새로운 Strict mode</li></ul></blockquote><p>자세한 사항은 <a href="https://reactjs.org/blog/2018/03/29/react-v-16-3.html" rel="external nofollow noopener noreferrer" target="_blank">공식사이트 포스트</a>를 참조하세요.</p><h2 id="Context-API"><a href="#Context-API" class="headerlink" title="Context API"></a>Context API</h2><p>간단히 말해서 Context 는 앱 전체에 공통으로 사용할 데이터를 담는 역할을 합니다. 저는 개발하면서 한번도 사용해본적은 없습니다만, react-redux, react-router 등의 react 관련 핵심 라이브러리에서 Context 가 사용되고 있습니다. 리덕스를 사용하고 있다면 아래와 같은 코드 조각을 본적이 있을 것입니다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span><br></pre></td></tr></table></figure><p>react-router 의 경우에는 브라우저 history 관리등을 위해 Context 를 사용하고 있습니다.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.props.history.<span class="keyword">push</span>(<span class="string">'/list'</span>);</span><br></pre></td></tr></table></figure><p>props 로 하위 컴포넌트에 데이터를 넘기는 전통적인 방식은 간단한 어플리케이션 개발에는 아무런 문제가 없습니다. 하지만 어플리케이션이 복잡해지고 하위 컴포넌트의 단계가 많아질수록 이런식의 상태 관리는 개발난이도가 높아질뿐 아니라 유지보수 측면에서도 문제를 야기할 수 있습니다. 이럴때 Context 는 하나의 대안이 될 수 있습니다.</p><p>이전 버전의 react 에도 Context API 가 있었습니다. 다만, 공식적인 API 라기보다는 실험적인 수준이었기 때문에 사용을 권장하지 않았습니다. 이번 v16.3.0 버전에서 공식적으로 <code>Context API</code>가 발표되었기 때문에 지금까지 Context 가 어떻게 쓰였고 앞으로 어떤 방식으로 사용 가능할지 알아볼 필요가 있겠습니다.</p><h3 id="기존-Context-API"><a href="#기존-Context-API" class="headerlink" title="기존 Context API"></a>기존 Context API</h3><p>실험적인 방법이라고하지만, 주요한 라이브러리에는 이미 context 를 사용하고 있습니다.</p><h4 id="App-jsx"><a href="#App-jsx" class="headerlink" title="App.jsx"></a>App.jsx</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;<span class="type">OldProvider</span> userId=<span class="string">"bono"</span> nickName=<span class="string">"보노"</span>&gt;</span><br><span class="line">        &lt;<span class="type">OldConsumer</span> /&gt;</span><br><span class="line">      &lt;/<span class="type">OldProvider</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="OldProvider-jsx"><a href="#OldProvider-jsx" class="headerlink" title="OldProvider.jsx"></a>OldProvider.jsx</h4><p><code>OldProvider</code>에서 context 데이터를 미리 만들어줍니다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">OldProvider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  static childContextTypes = &#123;</span><br><span class="line">    userId: <span class="type">PropTypes</span>.string,</span><br><span class="line">    nickName: <span class="type">PropTypes</span>.string</span><br><span class="line">  &#125;;</span><br><span class="line">  getChildContext = () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      userId: <span class="keyword">this</span>.props.userId,</span><br><span class="line">      nickName: <span class="keyword">this</span>.props.nickName</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;&#123;<span class="keyword">this</span>.props.children&#125;&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="OldConsumer-jsx"><a href="#OldConsumer-jsx" class="headerlink" title="OldConsumer.jsx"></a>OldConsumer.jsx</h4><p><code>Provider</code>로 감싸진 컴포넌트 어디에서든 <code>this.context</code>로 context 데이터에 접근이 가능합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">OldConsumer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; userId, nickName &#125; = <span class="keyword">this</span>.context;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;userId&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h2&gt;&#123;nickName&#125;&lt;/</span>h2&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="new-Context-API"><a href="#new-Context-API" class="headerlink" title="new Context API"></a>new Context API</h3><p>위의 기능을 새로 발표된 Context API 를 사용하여 구현합니다. 파일 개수가 하나더 증가했습니다. 하지만 생성, 공급, 소비와 같이 관심사가 확실하게 분리되기 때문에 훨씬더 구조적인 모습입니다.</p><h4 id="App-jsx-1"><a href="#App-jsx-1" class="headerlink" title="App.jsx"></a>App.jsx</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;<span class="type">Provider</span> userId=<span class="string">"bono"</span> nickName=<span class="string">"보노"</span>&gt;</span><br><span class="line">        &lt;<span class="type">Consumer</span> /&gt;</span><br><span class="line">      &lt;/<span class="type">Provider</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Context-jsx"><a href="#Context-jsx" class="headerlink" title="Context.jsx"></a>Context.jsx</h4><p><code>Provider</code>와 <code>Consumer</code>에서 공통으로 Context 객체를 사용하기 위해 Context.tsx 를 별도로 생성합니다.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span><span class="built_in"> default </span>React.createContext();</span><br></pre></td></tr></table></figure><h4 id="Provider-jsx"><a href="#Provider-jsx" class="headerlink" title="Provider.jsx"></a>Provider.jsx</h4><p>Context 객체에 데이터를 넣어주는 역할을 합니다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;<span class="type">Context</span>.<span class="type">Provider</span> value=&#123;<span class="keyword">this</span>.props&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">      &lt;/<span class="type">Context</span>.<span class="type">Provider</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Consumer-jsx"><a href="#Consumer-jsx" class="headerlink" title="Consumer.jsx"></a>Consumer.jsx</h4><p>Context 의 데이터를 사용하는 부분입니다. 좀 특이한 것은 <code>&lt;Context.Consumer&gt;</code> 컴포넌트 바로 아래가 React Element 를 리턴하는 함수 형태로 되어 있다는 것입니다. 이는 <a href="https://reactjs.org/docs/render-props.html" rel="external nofollow noopener noreferrer" target="_blank">Render Props</a>라는 패턴입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Context.Consumer&gt;</span><br><span class="line">        &#123;value =&gt; (</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;&#123;value.userId&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">            &lt;h2&gt;&#123;value.nickName&#125;&lt;/</span>h2&gt;</span><br><span class="line">          &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Context.Consumer&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Consumer 에서 context 를 사용할때마다 Render Props 패턴으로 context 의 데이터를 가져와야하는 부분이 거슬리는데, 이는 <code>HOC</code>를 이용해 context 의 value 를 prop 으로 가져오도록 구현하면 됩니다(자세한 구현은 생략).</p><p>Context API 를 사용한 위 두가지 방법은 각각 아래와 같은 형태로 출력됩니다.</p><img src="/2018/04/05/react-v16-3-0/context.png"><h2 id="Refs-API"><a href="#Refs-API" class="headerlink" title="Refs API"></a>Refs API</h2><p>ref 는 reference 의 줄임말로, 특정 컴포넌트를 참조합니다. 컴포넌트를 참조하기 때문에 컴포넌트 내의 변수나 상태, 메서드를 사용할 수 있습니다.</p><p>그 동안 Ref 사용시 <a href="https://github.com/facebook/react/issues/1373" rel="external nofollow noopener noreferrer" target="_blank">몇가지 문제점</a>이 있었는데, 이를 해결하기위해 새로운 Ref API 가 나왔습니다. 역시 이전의 ref 사용법과 비교해 보겠습니다.</p><h3 id="old-Ref"><a href="#old-Ref" class="headerlink" title="old Ref"></a>old Ref</h3><p>기존의 ref 는 string 형태로 정의합니다(아마 string 형태로 정의하는게 여러 문제를 야기하지 않았을까 추측해봅니다). ref 의 대상이 되는 컴포넌트에 ref 속성을 만들고 텍스트로 이름을 만들어줍니다. 그리고 <code>this.refs.xxx</code>와 같이 사용하면 됩니다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">OldRef</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.refs.oldRef.focus();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;span&gt;oldRef: &lt;/span&gt;</span><br><span class="line">        &lt;input <span class="class"><span class="keyword">type</span></span>=<span class="string">"text"</span> ref=<span class="string">"oldRef"</span> /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="new-Ref"><a href="#new-Ref" class="headerlink" title="new Ref"></a>new Ref</h3><p>공식문서의 예제와 동일한 형태입니다. 위의 OldRef 와 비교해보면, 우선 ref 가 string 에서 <code>객체형태</code>로 바꼈습니다. 그리고 <code>createRef()</code> 함수로 ref 를 만든 다음 실제 타겟 컴포넌트의 ref 속성에 해당 객체를 할당합니다. ref 를 사용할때는 생성자함수에서 만들어둔 <code>this.inputRef</code>를 그대로 이용합니다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">NewRef</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.inputRef = <span class="type">React</span>.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.inputRef.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;span&gt;newRef: &lt;/span&gt;</span><br><span class="line">        &lt;input <span class="class"><span class="keyword">type</span></span>=<span class="string">"text"</span> ref=&#123;<span class="keyword">this</span>.inputRef&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>새로 만들어진 ref API 에 한가지 한계가 있는데 HOC 로 만들어진 컴포넌트의 속성에 <code>ref</code>가 있으면 리턴되는 컴포넌트에서 이 ref 를 가져오지 못합니다. 이 문제를 해결하기 위해서는 HOC 내부에서 <code>forwardRedRef</code>를 이용하면 리턴되는 컴포넌트에 무사히 전달할 수 있습니다. 자주 사용할 것 같지 않은 API 이므로(나만 그런가..) 코드설명 없이 넘어가겠습니다.</p><h2 id="lifecycle-메서드"><a href="#lifecycle-메서드" class="headerlink" title="lifecycle 메서드"></a>lifecycle 메서드</h2><p>그 동안 <code>will</code> 관련 메서드가 deprecated 될것이라는 말이 비공식적으로 여러번 나왔습니다. 새로운 버전에서 드디어 이 말이 현실이 됐습니다. <code>componentWillUnMount</code>를 제외한 나머지 will 메서드들이 공식적으로 deprecated 되었으며, 기존 메서드를 사용하기 위해서는 <code>UNSAFE_</code> prefix 를 붙여줘야합니다. (ex. UNSAFE_componentWillMount, ㅎㄷㄷ) 쓰지 말라는 얘기죠.</p><p>그리고 두가지 새로운 메서드가 나왔습니다.</p><blockquote><ul><li><a href="https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops" rel="external nofollow noopener noreferrer" target="_blank">getDerivedStateFromProps</a></li><li><a href="https://reactjs.org/docs/react-component.html#getsnapshotbeforeupdate" rel="external nofollow noopener noreferrer" target="_blank">getSnapshotBeforeUpdate</a></li></ul></blockquote><p><code>getDerivedStateFromProps</code>는 componentWillReceiveProps 의 대안으로 사용할 수 있는 메서드입니다. 다만 차이가 있다면, 첫째로는 메서드 이름에서 알 수 있듯이 <code>return</code> 값이 존재(해야만)한다는 것이고, 또 static 메서드라는 점입니다. 이 메서드를 사용할때는 반드시(should) update 된 state 를 리턴해주어야합니다. 그리고 static 이기 때문에 <code>this</code> 키워드를 사용할 수 없습니다. 그래서 componentWillReceiveProps 의 완전한 대체제라고 말하기 어렵습니다. 만약 기존에 사용하던 componentWillReceiveProps 메서드에 <code>this</code>가 사용되고 있다면, getDerivedStateFromProps 가 아닌 <code>componentDidUpdate</code>를 대신 사용해야할 것입니다.</p><p><code>getSnapshotBeforeUpdate</code>는 가장 최근에 렌더링된 결과의 상태를 가져옵니다. 공식사이트에서 예를 든것처럼 새로 렌더링 되기전 scroll 상태를 기억하고 있다가 렌더링 된 후에 다시 이전 scroll 위치로 돌아올때 유용하게 사용될 수 있을것 같습니다.</p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p>이번 v16.3.0 에서 가장 큰 부분은 Context API 와 lifecycle 메서드의 변화입니다. Context API 는 react 주요 라이브러리에서 많이 사용되고 있었던 만큼 각 라이브러리에 새로운 Context API 가 적용될 것입니다. 그리고 공식적으로 나온 API 이기 때문에 컴포넌트 depth 가 큰 곳에는 적절히 사용할 수도 있을것 같습니다. lifecycle 메서드는 리액트의 앞으로의 방향인 <a href="https://www.youtube.com/watch?v=v6iR3Zk4oDY" rel="external nofollow noopener noreferrer" target="_blank">Async Mode</a>에 맞게 재조정된것이라 생각합니다. 여담이지만, react 의 인기가 높은 만큼 변화도 빨라서 지속적인 관심이 없으면 따라가기 벅찰지도 모르겠습니다. 앞으로도 꾸준한 관심이 필요할 것 같습니다.</p><h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><ul><li><a href="https://reactjs.org/blog/2018/03/29/react-v-16-3.html" rel="external nofollow noopener noreferrer" target="_blank">https://reactjs.org/blog/2018/03/29/react-v-16-3.html</a></li><li><a href="https://www.youtube.com/watch?v=WhWqy-vxKS8&amp;t=204s" rel="external nofollow noopener noreferrer" target="_blank">https://www.youtube.com/watch?v=WhWqy-vxKS8&amp;t=204s</a></li><li><a href="https://velopert.com/3606" rel="external nofollow noopener noreferrer" target="_blank">https://velopert.com/3606</a></li><li><a href="https://www.youtube.com/watch?v=v6iR3Zk4oDY" rel="external nofollow noopener noreferrer" target="_blank">https://www.youtube.com/watch?v=v6iR3Zk4oDY</a></li></ul><hr><ul class="pager"><li class="next"><a href="/2018/03/25/priority-css-selector/" data-toggle="tooltip" data-placement="top" title="[CSS] styled-jsx 버그 보고 경험기 (사실은 stylis js 버그)">Next Post &rarr;</a></li></ul><div class="comment"><div id="disqus_thread" class="disqus-thread"></div></div></div><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 sidebar-container"><section><h5><a href="/tags/">FEATURED TAGS</a></h5><div class="tags"><a class="tag" href="/tags/#react" title="react">react</a> <a class="tag" href="/tags/#v16.3.0" title="v16.3.0">v16.3.0</a></div></section></div></div></div></article><script type="text/javascript">var disqus_shortname="bonogithub",disqus_identifier="http://blueshw.github.io/2018/04/05/react-v16-3-0/",disqus_url="http://blueshw.github.io/2018/04/05/react-v16-3-0/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a target="_blank" href="https://twitter.com/blueshw" rel="external nofollow noopener noreferrer"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-twitter fa-stack-1x fa-inverse"></i></span></a></li><li><a target="_blank" href="https://www.facebook.com/blueshw" rel="external nofollow noopener noreferrer"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-facebook fa-stack-1x fa-inverse"></i></span></a></li><li><a target="_blank" href="https://github.com/blueshw" rel="external nofollow noopener noreferrer"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 보노의 블로그 2018</p></div></div></div></footer><script src="/js/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/hux-blog.min.js"></script><script>function async(e,n){var t=document,a="script",r=t.createElement(a),c=t.getElementsByTagName(a)[0];r.src=e,n&&r.addEventListener("load",function(e){n(null,e)},!1),c.parentNode.insertBefore(r,c)}</script><script>0!==$("#tag_cloud").length&&async("http://blueshw.github.io/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js",function(){var c=document.querySelector("nav");c&&FastClick.attach(c)})</script><script>var _gaId="UA-50048807-2",_gaDomain="blueshw.github.io";!function(a,e,g,n,t,o,c){a.GoogleAnalyticsObject="ga",a.ga=a.ga||function(){(a.ga.q=a.ga.q||[]).push(arguments)},a.ga.l=1*new Date,o=e.createElement(g),c=e.getElementsByTagName(g)[0],o.async=1,o.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(o,c)}(window,document,"script"),ga("create",_gaId,_gaDomain),ga("send","pageview")</script><img src="http://blueshw.github.io/img/icon_wechat.png" width="0" height="0"></body></html>