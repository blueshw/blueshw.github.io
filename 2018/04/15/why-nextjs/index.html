<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="R3ZeY1PmaJUY9j_cgNABjesJFgHWVCJpb4TsdfXntMA"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content=""><meta name="keyword" content=""><link rel="shortcut icon" href="/img/favicon2.ico"><link rel="canonical" href="http://blueshw.github.io/2018/04/15/why-nextjs/"><title>[nextjs] nextjs는 어떻게 동작하는가? - 보노의블로그 | Bono&#39;s Blog</title><link rel="canonical" href="http://blueshw.github.io/2018/04/15/why-nextjs/"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/hux-blog.css?v=20180409"><link rel="stylesheet" href="/css/highlight.css"><link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]--><script></script></head><body ontouchstart=""><nav class="navbar navbar-default navbar-fixed-top"><div class="container-fluid"><div class="navbar-header page-scroll"><button type="button" class="navbar-toggle"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand" href="/">보노의 블로그</a></div><div id="huxblog_navbar"><div class="navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="/">Home</a></li><li><a href="/about/">About</a></li><li><a href="/tags/">Tags</a></li><li><a href="/archives/">Archives</a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");function handleMagic(e){0<$navbar.className.indexOf("in")?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}$toggle.addEventListener("click",handleMagic)</script><style type="text/css"></style><header class="intro-header"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-heading"><div class="tags"><a class="tag" href="/tags/#react" title="react">react</a> <a class="tag" href="/tags/#nextjs" title="nextjs">nextjs</a></div><h1>[nextjs] nextjs는 어떻게 동작하는가?</h1><h2 class="subheading"></h2><span class="meta">Posted by bono on 2018-04-15</span></div></div></div></div></header><article><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container"><p>nextjs로 프로젝트를 진행한지도 반년 가까이 흘렀습니다. <a href="https://github.com/zeit/next.js/" rel="external nofollow noopener noreferrer" target="_blank">nextjs</a>는 서버사이드렌더링(SSR)과 code splitting 등을 지원하는 reactjs 전용 프레임워크입니다. 2년도 채 안되는 시간에 벌써 5.x(곧 버전 6도 나올것 같네요) 버전까지 등장했습니다. 그만큼 많은 사람들의 관심속에 발전하고 있다는 뜻이겠죠. 사용법은 충분히 익숙해졌지만, 시간에 쫓기고 일정에 쫓기다보니 nextjs가 동작하는 방식에대한 이해는 부족하다 느껴집니다. nextjs가 reactjs 코드를 어떻게 빌드하고, SSR은 어떤 과정을 거치며 브라우저에서 어떻게 동작하는지 살펴보도록 하겠습니다.</p><p>우선 프로젝트를 생성합니다.</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> why-<span class="keyword">next</span></span><br><span class="line"><span class="keyword">cd</span> why-<span class="keyword">next</span></span><br><span class="line">npm init</span><br><span class="line">npm install --save <span class="keyword">next</span> react react-dom</span><br></pre></td></tr></table></figure><p>그리고 <code>package.json</code>파일에 다음의 스크립트를 추가합니다.</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"next"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"next build"</span>,</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"next start"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>프로젝트 생성은 여기서 끝입니다. 이 후에는 페이지(pages 폴더에)를 만들어 실행하면 됩니다.</p><h3 id="nextjs의-빌드과정"><a href="#nextjs의-빌드과정" class="headerlink" title="nextjs의 빌드과정"></a>nextjs의 빌드과정</h3><p>nextjs를 사용하기 위해서 반드시 따라야 할 규칙이 있습니다. pages 폴더(없다면 만들어야함)에 라우팅 url과 동일한 이름의 컴포넌트를 생성해야 합니다. pages 컴포넌트가 next 라우팅과 동일하게 mapping되기 때문에 이 규칙은 반드시 지켜야합니다. 예를들어 url이 <code>/first</code>이라면 <code>pages/first.jsx</code> 파일을 만들어야합니다. 테스트를 위해 pages/index.jsx와 pages/second.jsx 파일을 생성합니다.</p><h4 id="pages-index-jsx"><a href="#pages-index-jsx" class="headerlink" title="pages/index.jsx"></a>pages/index.jsx</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">"next/link"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Index Page&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Link href="/</span>second<span class="string">"&gt;</span></span><br><span class="line"><span class="string">      &lt;a&gt;second2&lt;/a&gt;</span></span><br><span class="line"><span class="string">    &lt;/Link&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">);</span></span><br></pre></td></tr></table></figure><h4 id="pages-second-jsx"><a href="#pages-second-jsx" class="headerlink" title="pages/second.jsx"></a>pages/second.jsx</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Second Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>그 다음 실행합니다.</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">run</span><span class="bash"> dev (dev 환경)</span></span><br><span class="line"><span class="bash">npm run build &amp;&amp; npm start (production 환경)</span></span><br></pre></td></tr></table></figure><p>위 명령은 package.json에 <code>next</code>라는 명령어를 실행하는 npm 커맨드입니다. 빌드가 진행되고 서버를 실행합니다. 빌드는 아래의 항목을 포함합니다.</p><blockquote><ul><li>자동 코드 트래스파일(babel) 및 번들링(webpack)</li><li>hot code reloading</li><li>서버렌더링 및 pages 폴더의 indexing</li><li>./static/ 폴더의 리소스의 /static path 접근</li></ul></blockquote><p>빌드가 완료되면, 프로젝트에 <code>.next</code> 폴더가 생성됩니다. <code>.next</code> 폴더 구조는 다음과 같습니다.<br></p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .map 파일 제외</span></span><br><span class="line">.next/                    <span class="comment"># 빌드 root 디렉토리</span></span><br><span class="line">  bundles/                </span><br><span class="line">    pages/</span><br><span class="line">      _error.js</span><br><span class="line">      (index.js)          <span class="comment"># production 환경에서 생성</span></span><br><span class="line">      (<span class="keyword">second</span>.js)         <span class="comment"># production 환경에서 생성</span></span><br><span class="line">  dist/                   <span class="comment"># 실제 렌더링 되는 파일들이 담긴 폴더</span></span><br><span class="line">    bundles/</span><br><span class="line">      pages/</span><br><span class="line">        _document.js</span><br><span class="line">        _error.js</span><br><span class="line">        (index.js)          <span class="comment"># production 환경에서 생성</span></span><br><span class="line">        (<span class="keyword">second</span>.js)         <span class="comment"># production 환경에서 생성</span></span><br><span class="line">  main.js                 <span class="comment"># 번들된 javascript 파일</span></span><br><span class="line">  manifest.js</span><br></pre></td></tr></table></figure><p></p><p>아직 서버에서 실행할 page 자바스크립트가 만들어지지 않았습니다. 이 경우에 모든 렌더링 관련 코드는 main.js에 포함됩니다. 이는 dev 환경일때만 해당되는 것으로 라우팅 될 때마다 필요한 페이지를 생성합니다. production 환경에서는 page 코드를 미리 준비합니다. 더 빠른 초기 렌더링이 가능하기 때문입니다. dev 환경에서는 빠른 빌드가 주 목적이기 때문에 미리 page를 생성하지 않습니다. 반면에 production 환경에서는 초기 렌더링을 빠르게 하는것이 주 목적이기 때문에 page 코드를 미리 생성합니다.</p><p>브라우저를 열고 <code>localhost:3000/</code>를 입력합니다. 다음과 같은 화면이 출력됩니다.</p><img src="/2018/04/15/why-nextjs/index.png"><p>폴더 구조를 다시 보면, .next 폴더 안에 bundles/page/index.js와 dist/bundles/page/index.js가 만들어진것을 확인할 수 있습니다.<br>그리고 url을 입력할때마다 <code>.next</code> 폴더에 <code>0.[hash].hot-update.js</code>와 같은 파일이 생성됩니다. 이는 page 코드를 만들때(서버든 클라이언트든) 동적으로 생성되는 js 파일입니다. dev에만 해당되는 내용으로 production 환경에서는 생성되지 않습니다.</p><h3 id="SSR은-어떤-과정을-거치나"><a href="#SSR은-어떤-과정을-거치나" class="headerlink" title="SSR은 어떤 과정을 거치나?"></a>SSR은 어떤 과정을 거치나?</h3><p>SSR은 말그대로 서버에서 렌더링을 한다는 것입니다. 10여년전에 많이 유행했던 PHP나 JSP가 대표적인 서버렌더링 프레임워크입니다. 유저가 어떤 url로 데이터를 요청하면 서버는 미리 html 파일을 만들어 클라이언트(브라우저)에게 전달하는 방식입니다. next에서 SSR도 크게 다르지 않습니다. 서버(node)를 띄우고 유저가 요청하면 html을 생성하여 브라우저에 전달합니다. 구조는 동일합니다. 다른점이 있다면, 모든 요청에 대해 서버에서 렌더링을 진행하지는 않고 초기 렌더링만 서버가 담당합니다. 그 이후에는 <code>next/router</code>를 이용하여 클라이언트에서 렌더링합니다. next가 해주는 일은 이게 전부입니다. 간단하지만, 이 방식으로 SPA의 단점으로 꼽히는 긴 초기 렌더링 시간을 대폭 줄일 수 있습니다.</p><img src="/2018/04/15/why-nextjs/ssr.png"><h3 id="어떤-과정으로-실행되는가"><a href="#어떤-과정으로-실행되는가" class="headerlink" title="어떤 과정으로 실행되는가?"></a>어떤 과정으로 실행되는가?</h3><p>위 코드를 바탕으로 실행과정을 단계별로 나눠보겠습니다.</p><ol><li>유저가 브라우저에 <code>/index</code>를 입력합니다.</li><li>미리 실행되고 있는 node 서버가 요청을 받고 서버렌더링을 합니다.</li><li>만들어진 html을 브라우저에게 보냅니다.</li><li>브라우저가 응답받은 html을 그립니다.</li><li>html에 기능을 부여할 <code>main.js</code>파일을 다운로드 받습니다. (라우팅 될 페이지 코드도 함께 번들링되어 있습니다.)</li><li>다운로드가 완료되고 <code>go to second</code> 링크를 클릭합니다.</li><li><code>/second</code>로 라우팅하고 second 페이지 코드를 생성합니다. (production에서는 미리 만들어진 코드를 사용합니다.)</li></ol><p>dev 환경에서는 2번과 7번에서 서버렌더링 코드가 만들어져 있지 않기 때문에 렌더링하는데 어느정도 시간이 소요됩니다. 하지만 production 환경에서는 미리 모든 페이지의 코드를 만들어두기 때문에 초기 렌더링 시간이 절약됩니다.</p><h3 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h3><p>SSR이 간단한 개념이지만, 이해하기는 쉽지 않습니다. 개념은 간단하지만 효율적으로 구현하기 위한 기반기술이 많기 때문이라 생각합니다. 사용법만 익혀도 nextjs 프로젝트를 진행하는데 큰 어려움은 없습니다. 하지만 SSR 관련해서 다양한 이슈가 발생했을때 대처하기 위해서는 next의 동작배경을 잘 알고 있어야 합니다. 초반에 글을 쓸 때는 next 내부 코드를 살펴보며 세밀한 동작 원리를 설명하고 싶었습니다. 코드를 살펴볼수록 이해하는 시간이 길어지고 담을 내용이 많아지는 것 같아 이정도로 마무리하려고 합니다. 잠깐씩 언급했던 세부적인 next 기반 기술은 앞으로 주제를 정해 하나씩 다룰 생각입니다. 잘못 알고 있는 내용이 있다면 지적 부탁드립니다.</p><h3 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h3><ul><li><a href="https://github.com/zeit/next.js/issues/1217" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/zeit/next.js/issues/1217</a></li><li><a href="https://www.codementor.io/tgreco/5-of-the-many-things-to-love-about-zeit-s-next-js-bpszu99g1" rel="external nofollow noopener noreferrer" target="_blank">https://www.codementor.io/tgreco/5-of-the-many-things-to-love-about-zeit-s-next-js-bpszu99g1</a></li><li><a href="https://www.slideshare.net/dotPKG/nextjs-a-javascript-framework-for-building-next-generation-spa" rel="external nofollow noopener noreferrer" target="_blank">https://www.slideshare.net/dotPKG/nextjs-a-javascript-framework-for-building-next-generation-spa</a></li></ul><hr><ul class="pager"><li class="next"><a href="/2018/04/05/react-v16-3-0/" data-toggle="tooltip" data-placement="top" title="[react] v16.3.0, 무엇이 바뀌었나?">Next Post &rarr;</a></li></ul><div class="comment"><div id="disqus_thread" class="disqus-thread"></div></div></div><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 sidebar-container"><section><h5><a href="/tags/">FEATURED TAGS</a></h5><div class="tags"><a class="tag" href="/tags/#react" title="react">react</a> <a class="tag" href="/tags/#nextjs" title="nextjs">nextjs</a></div></section></div></div></div></article><script type="text/javascript">var disqus_shortname="bonogithub",disqus_identifier="http://blueshw.github.io/2018/04/15/why-nextjs/",disqus_url="http://blueshw.github.io/2018/04/15/why-nextjs/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a target="_blank" href="https://twitter.com/blueshw" rel="external nofollow noopener noreferrer"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-twitter fa-stack-1x fa-inverse"></i></span></a></li><li><a target="_blank" href="https://www.facebook.com/blueshw" rel="external nofollow noopener noreferrer"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-facebook fa-stack-1x fa-inverse"></i></span></a></li><li><a target="_blank" href="https://github.com/blueshw" rel="external nofollow noopener noreferrer"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 보노의 블로그 2018</p></div></div></div></footer><script src="/js/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/hux-blog.min.js"></script><script>function async(e,n){var t=document,a="script",r=t.createElement(a),c=t.getElementsByTagName(a)[0];r.src=e,n&&r.addEventListener("load",function(e){n(null,e)},!1),c.parentNode.insertBefore(r,c)}</script><script>0!==$("#tag_cloud").length&&async("http://blueshw.github.io/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js",function(){var c=document.querySelector("nav");c&&FastClick.attach(c)})</script><script>var _gaId="UA-50048807-2",_gaDomain="blueshw.github.io";!function(a,e,g,n,t,o,c){a.GoogleAnalyticsObject="ga",a.ga=a.ga||function(){(a.ga.q=a.ga.q||[]).push(arguments)},a.ga.l=1*new Date,o=e.createElement(g),c=e.getElementsByTagName(g)[0],o.async=1,o.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(o,c)}(window,document,"script"),ga("create",_gaId,_gaDomain),ga("send","pageview")</script><img src="http://blueshw.github.io/img/icon_wechat.png" width="0" height="0"></body></html>