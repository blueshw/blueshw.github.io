<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="R3ZeY1PmaJUY9j_cgNABjesJFgHWVCJpb4TsdfXntMA"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content=""><meta name="keyword" content=""><link rel="shortcut icon" href="/img/favicon2.ico"><link rel="canonical" href="http://blueshw.github.io/2018/04/23/event-bubbling-capturing/"><title>리액트(react)에서 이벤트 버블링(bubbling)과 캡쳐링(capturing) 사용하기 - 보노의블로그 | Bono&#39;s Blog</title><link rel="canonical" href="http://blueshw.github.io/2018/04/23/event-bubbling-capturing/"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/hux-blog.css?v=20180409"><link rel="stylesheet" href="/css/highlight.css"><link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]--><script></script></head><body ontouchstart=""><nav class="navbar navbar-default navbar-fixed-top"><div class="container-fluid"><div class="navbar-header page-scroll"><button type="button" class="navbar-toggle"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand" href="/">보노의 블로그</a></div><div id="huxblog_navbar"><div class="navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="/">Home</a></li><li><a href="/about/">About</a></li><li><a href="/archives/">Archives</a></li><li><a href="/tags/">Tags</a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");function handleMagic(e){0<$navbar.className.indexOf("in")?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}$toggle.addEventListener("click",handleMagic)</script><style type="text/css"></style><header class="intro-header"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-heading"><div class="tags"><a class="tag" href="/tags/#HTML" title="HTML">HTML</a> <a class="tag" href="/tags/#react" title="react">react</a> <a class="tag" href="/tags/#DOM" title="DOM">DOM</a> <a class="tag" href="/tags/#event" title="event">event</a> <a class="tag" href="/tags/#bubbling" title="bubbling">bubbling</a> <a class="tag" href="/tags/#capturing" title="capturing">capturing</a></div><h1>리액트(react)에서 이벤트 버블링(bubbling)과 캡쳐링(capturing) 사용하기</h1><h2 class="subheading"></h2><span class="meta">Posted by bono on 2018-04-23</span></div></div></div></div></header><article><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container"><h3 id="이벤트-버블링-캡쳐링"><a href="#이벤트-버블링-캡쳐링" class="headerlink" title="이벤트 버블링 / 캡쳐링"></a>이벤트 버블링 / 캡쳐링</h3><p>특정 DOM 노드에서 발생한 이벤트는 부모 또는 자식으로 전파됩니다. 자기자신(currentTarget)에서 부모로 전파되면 이벤트 버블링(event bubbling)이라 하고, 부모에서 자기 자신으로 전파되면 이벤트 캡쳐링(event capturing)이라 합니다. 이벤트가 발생하면 우선 window부터 target node까지 이벤트 캡쳐링합니다<code>(capture phase(1))</code>. 그 다음 타켓 노드에 이벤트가 발생<code>(target phase(2))</code>하고 마지막으로 이벤트를 한단계씩 상위로 버블링<code>(bubbling phase(3))</code>합니다. (이미지 출처: <a href="http://www.w3.org" rel="external nofollow noopener noreferrer" target="_blank">www.w3.org</a>)</p><img src="/2018/04/23/event-bubbling-capturing/event.png"><p>이벤트 발생 시점이 다르기 때문에 이벤트 핸들러를 <code>binding</code>할때 주의가 필요합니다. 보통은 아래처럼 작성합니다. 세번째 인자가 없거나 <code>false</code>면 버블링, <code>true</code>면 캡쳐링시에 이벤트가 발생합니다. target 노드는 바인딩 방식과는 상관없이 캡쳐링이 끝나면 이벤트가 발생합니다.</p><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="comment">// event bubbling</span></span><br><span class="line">element.addEventListener(<span class="string">'click'</span>, <span class="keyword">handler</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// event capturing</span></span><br><span class="line">element.addEventListener(<span class="string">'click'</span>, <span class="keyword">handler</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>모바일에서 가운데 영역을 터치하면 메뉴가 나타나거나 사라지고 좌우를 클릭하면 페이지가 좌우로 이동하는 기능이 있다고 가정합니다. 메뉴가 켜져 있으면 상단에 세개 버튼이 노출됩니다.</p><img src="/2018/04/23/event-bubbling-capturing/mobile.png"><p>가운데 영역을 터치해서 메뉴가 오픈된 상태에서 왼쪽 버튼을 터치합니다. 이 영역은 페이지를 좌측으로 이동하는 영역과 겹쳐있습니다. 터치이벤트가 발생하면 좌측 페이지로 이동하는 이벤트와 <code>홈</code> 버튼의 터치 이벤트가 발생합니다. 일반적으로 전체 영역(window or document)은 홈버튼의 부모 노드입니다. 이 때 전체영역과 홈버튼의 이벤트를 어떻게 바인딩(캡쳐링 or 버블링)했냐에 따라 이벤트 발생 순서는 완전히 바뀝니다. 일반적으로 세번째 인자를 쓰지 않고(or false) 바인딩하면, <code>bubbling</code> 시점에 이벤트가 발생합니다. target 노드인 leftButton의 이벤트가 먼저 발생합니다. 그 후에 이벤트가 부모로 버블링되면서 window의 click 이벤트가 발생합니다.</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">window</span><span class="selector-class">.addEventListener</span>(<span class="string">'click'</span>, clickHandler);</span><br><span class="line"><span class="selector-tag">leftButton</span><span class="selector-class">.addEventListener</span>(<span class="string">'click'</span>, clickBtnHandler);</span><br></pre></td></tr></table></figure><p>반대로 아래처럼 <code>capturing</code> 방식으로 바인딩했다면 최상위 노드가 가장먼저 실행됩니다. 즉, window의 이벤트가 가장 먼저 발생합니다. 이 후 이벤트가 캡쳐링되면서 target 노드인 leftButton의 <code>click</code> 이벤트가 발생합니다.</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'click'</span>, clickHandler, <span class="literal">true</span>);</span><br><span class="line">leftButton.addEventListener(<span class="string">'click'</span>, clickBtnHandler, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="react에서-이벤트-버블링-캡쳐링-사용하기"><a href="#react에서-이벤트-버블링-캡쳐링-사용하기" class="headerlink" title="react에서 이벤트 버블링 / 캡쳐링 사용하기"></a>react에서 이벤트 버블링 / 캡쳐링 사용하기</h3><p>리액트에서 이벤트 버블링과 캡쳐링 사용은 어렵지 않습니다. click 이벤트의 경우에는 <code>onClick</code>은 버블링, <code>onClickCapture</code>는 캡쳐링을 사용합니다.</p><p>위에서 보았던 예제를 바탕으로 이벤트 캡쳐링/버블링 테스트를 위해 아래처럼 코드를 입력합니다. 코드에서 사용한 <code>onClick</code> 속성은 버블링 방식으로 이벤트를 바인딩하기 때문에 자기자신의 이벤트가 먼저 발생하고 부모로 이벤트를 전파합니다. 우선 가운데 영역을 클릭해 상단 메뉴를 열어줍니다. 그리고 왼쪽의 <code>HOME</code> 버튼을 클릭합니다. 각 노드의 이벤트가 bubbling 방식으로 동작하기 때문에 <code>home</code>이 먼저 출력되고 <code>left</code>가 출력됩니다.</p><h4 id="이벤트-bubbling"><a href="#이벤트-bubbling" class="headerlink" title="이벤트 bubbling"></a>이벤트 bubbling</h4><p></p><p data-height="450" data-theme-id="0" data-slug-hash="QrjmBG" data-default-tab="js,result" data-user="blueshw" data-embed-version="2" data-pen-title="event bubbling  in react" class="codepen">See the Pen <a href="https://codepen.io/blueshw/pen/QrjmBG/" rel="external nofollow noopener noreferrer" target="_blank">event bubbling in react</a> by Hyunwoo Seo (<a href="https://codepen.io/blueshw" rel="external nofollow noopener noreferrer" target="_blank">@blueshw</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.</p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="이벤트-capturing"><a href="#이벤트-capturing" class="headerlink" title="이벤트 capturing"></a>이벤트 capturing</h4><p>이번에는 캡쳐링을 살펴보겠습니다. 이벤트 캡쳐링과 버블링을 비교하기 위해 <code>menuBox</code>에 이벤트를 추가합니다. background와 home버튼은 <code>onClickCapture</code>로 바인딩(캡쳐링)하고, menuBox에는 <code>onClick</code>으로 바인딩(버블링)합니다. 위에서 이벤트가 발생하는 순서는 <code>캡쳐링 -&gt; 타겟노드 -&gt; 버블링</code>이므로 가장먼저 <code>left</code>가 출력됩니다. 그 다음은 타켓노드의 이벤트가 발생해서 <code>home</code>이 출력됩니다. 타켓노드 이후에 이벤트가 버블링 되고 menuBox에 <code>click menu</code>가 출력됩니다.</p><p></p><p data-height="450" data-theme-id="0" data-slug-hash="pVjLmW" data-default-tab="js,result" data-user="blueshw" data-embed-version="2" data-pen-title="event capturing in react" class="codepen">See the Pen <a href="https://codepen.io/blueshw/pen/pVjLmW/" rel="external nofollow noopener noreferrer" target="_blank">event capturing in react</a> by Hyunwoo Seo (<a href="https://codepen.io/blueshw" rel="external nofollow noopener noreferrer" target="_blank">@blueshw</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.</p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h4><p>이벤트는 <code>캡처링 -&gt; 타겟노드 -&gt; 버블링</code>의 순서로 발생합니다. 캡처링은 가장 상위(window)에서 먼저 이벤트가 발생하고 자식으로 한단계씩 전파합니다. 타켓노드까지 이벤트가 전파된 후에는 반대로 한단계씩 부모로 전파됩니다. 각 노드에서 바인딩(binding)된 이벤트 핸들러가 capture 방식이라면 이벤트 캡쳐링시에 실행되고, 반대로 bubbling 방식이라면 이벤트 버블링시에 실행됩니다. target 노드에 바인딩된 핸들러는 capture의 사용 유무와 상관없이 이벤트 캡쳐가 끝나면 실행됩니다.</p><h3 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h3><ul><li><a href="https://www.w3.org/TR/DOM-Level-3-Events/#dom-event-architecture" rel="external nofollow noopener noreferrer" target="_blank">https://www.w3.org/TR/DOM-Level-3-Events/#dom-event-architecture</a></li></ul><hr><ul class="pager"><li class="next"><a href="/2018/04/15/why-nextjs/" data-toggle="tooltip" data-placement="top" title="[nextjs] nextjs는 어떻게 동작하는가?">Next Post &rarr;</a></li></ul><div class="comment"><div id="disqus_thread" class="disqus-thread"></div></div></div><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 sidebar-container"><section><h5><a href="/tags/">FEATURED TAGS</a></h5><div class="tags"><a class="tag" href="/tags/#HTML" title="HTML">HTML</a> <a class="tag" href="/tags/#react" title="react">react</a> <a class="tag" href="/tags/#DOM" title="DOM">DOM</a> <a class="tag" href="/tags/#event" title="event">event</a> <a class="tag" href="/tags/#bubbling" title="bubbling">bubbling</a> <a class="tag" href="/tags/#capturing" title="capturing">capturing</a></div></section></div></div></div></article><script type="text/javascript">var disqus_shortname="bonogithub",disqus_identifier="http://blueshw.github.io/2018/04/23/event-bubbling-capturing/",disqus_url="http://blueshw.github.io/2018/04/23/event-bubbling-capturing/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a target="_blank" href="https://twitter.com/blueshw" rel="external nofollow noopener noreferrer"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-twitter fa-stack-1x fa-inverse"></i></span></a></li><li><a target="_blank" href="https://www.facebook.com/blueshw" rel="external nofollow noopener noreferrer"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-facebook fa-stack-1x fa-inverse"></i></span></a></li><li><a target="_blank" href="https://github.com/blueshw" rel="external nofollow noopener noreferrer"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 보노의 블로그 2018</p></div></div></div></footer><script src="/js/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/hux-blog.min.js"></script><script>function async(e,n){var t=document,a="script",r=t.createElement(a),c=t.getElementsByTagName(a)[0];r.src=e,n&&r.addEventListener("load",function(e){n(null,e)},!1),c.parentNode.insertBefore(r,c)}</script><script>0!==$("#tag_cloud").length&&async("http://blueshw.github.io/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js",function(){var c=document.querySelector("nav");c&&FastClick.attach(c)})</script><script>var _gaId="UA-50048807-2",_gaDomain="blueshw.github.io";!function(a,e,g,n,t,o,c){a.GoogleAnalyticsObject="ga",a.ga=a.ga||function(){(a.ga.q=a.ga.q||[]).push(arguments)},a.ga.l=1*new Date,o=e.createElement(g),c=e.getElementsByTagName(g)[0],o.async=1,o.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(o,c)}(window,document,"script"),ga("create",_gaId,_gaDomain),ga("send","pageview")</script><img src="http://blueshw.github.io/img/icon_wechat.png" width="0" height="0"></body></html>