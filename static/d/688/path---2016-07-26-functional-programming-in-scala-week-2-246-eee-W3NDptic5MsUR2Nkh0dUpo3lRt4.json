{"data":{"site":{"siteMetadata":{"title":"bono's blog","author":"bono"}},"markdownRemark":{"id":"a8bf1acd-f4dd-564b-943e-ac4ce47c0d4d","excerpt":"2.1 Higher-Order Functions 함수형 언어에서는 function 이 first-class value 이다. 이 말은 특정 함수가 다른 함수의 파라미터나 결과로써 return 될 수 있다는 것이다(higher order…","html":"<h2>2.1 Higher-Order Functions</h2>\n<p>함수형 언어에서는 function 이 first-class value 이다. 이 말은 특정 함수가 다른 함수의 파라미터나 결과로써 return 될 수 있다는 것이다(higher order functions).</p>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;sum(f:&nbsp;Int&nbsp;=&gt;&nbsp;Int,&nbsp;a:&nbsp;Int,&nbsp;b:&nbsp;Int):&nbsp;Int&nbsp;=</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;if&nbsp;(a&nbsp;&gt;&nbsp;b)&nbsp;0</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;else&nbsp;f(a)&nbsp;+&nbsp;sum(f,&nbsp;a+1,&nbsp;b)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;sumInts(a:&nbsp;Int,&nbsp;b:&nbsp;Int)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;sum(id,&nbsp;a,&nbsp;b)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;sumCubes(a:&nbsp;Int,&nbsp;b:&nbsp;Int)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;sum(cube,&nbsp;a,&nbsp;b)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;sumFactorials(a:&nbsp;Int,&nbsp;b:&nbsp;Int)&nbsp;=&nbsp;sum(fact,&nbsp;a,&nbsp;b)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;id(x:&nbsp;Int):&nbsp;Int&nbsp;=&nbsp;x</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;cube(x:&nbsp;Int):&nbsp;Int&nbsp;=&nbsp;x&nbsp;*&nbsp;x&nbsp;*&nbsp;x</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;fact(x:&nbsp;Int):&nbsp;Int&nbsp;=&nbsp;if&nbsp;(x&nbsp;==&nbsp;0)&nbsp;1&nbsp;else&nbsp;x&nbsp;*&nbsp;fact(x&nbsp;-1)</span></span></div></pre></div>\n<p>sum() 함수의 첫번째 파라미터로 f 라는 임의의 함수가 들어가 있다.\n이는 Int 파라미터를 받아서 Int 타입을 리턴하는 함수라면 이 파라미터 위치에 적합하다라는 뜻이다. 즉, 어떠한 함수가 됐든간에 저 유형만 유지하면 된다. 재사용 가능하다는 말이다. 실제로 sumInts(), sumCubes(), sumFactorials() 함수는 모두 sum()함수를 호출한다. sum()함수의 첫번째 파라미터는 각각 id(), cube(), fact()함수를 호출하게 되는데 세 함수 모두 파라미터와 리턴 타입이 Int 이므로 sum()함수의 파라미터로 적합하다.</p>\n<h3>익명함수</h3>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>(x:&nbsp;Int,&nbsp;y:Int)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;y</span></span></div></pre></div>\n<p>익명함수는 보통 함수를 선언하는 방식과는 달리 이름이 없다.\n대신 파라미터 타입과 body 만 존재한다.</p>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;sumCubes(a:&nbsp;Int,&nbsp;b:&nbsp;Int)&nbsp;=&nbsp;sum(x&nbsp;=&gt;&nbsp;x&nbsp;*&nbsp;x&nbsp;*&nbsp;x,&nbsp;a,&nbsp;b)</span></span></div></pre></div>\n<p>위에서 보았던 sumCubes 의 익명함수 버전이다.\ncube() 함수가 재사용되지 않는다고 가정한다면 매우 심플하기 때문에 따로 함수를 선언하기 보다는 sum() 파라미터에 익명함수로 직접 선언할수 있다.</p>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>//&nbsp;linear&nbsp;recursion,&nbsp;a와&nbsp;b의&nbsp;차이가&nbsp;커지면&nbsp;stackOverFlow&nbsp;익셉션이&nbsp;발생할&nbsp;수&nbsp;있다.</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;sum(f:&nbsp;Int&nbsp;=&gt;&nbsp;Int,&nbsp;a:&nbsp;Int,&nbsp;b:&nbsp;Int):&nbsp;Int&nbsp;=</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;if&nbsp;(a&nbsp;&gt;&nbsp;b)&nbsp;0</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;else&nbsp;f(a)&nbsp;+&nbsp;sum(f,&nbsp;a+1,&nbsp;b)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>//&nbsp;tail-recursive&nbsp;version</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;sum(f:&nbsp;Int&nbsp;=&gt;&nbsp;Int,&nbsp;a:&nbsp;Int,&nbsp;b:&nbsp;Int):&nbsp;Int&nbsp;=&nbsp;{</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;def&nbsp;loop(a:&nbsp;Int,&nbsp;acc:&nbsp;Int):&nbsp;Int&nbsp;=&nbsp;{</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;if(a&nbsp;&gt;&nbsp;b)&nbsp;acc</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;loop(a+1,&nbsp;f(a)+acc)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;}</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;loop(a,&nbsp;0)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>}</span></span></div></pre></div>\n<h2>2.2 Currying</h2>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;sumInts(a:&nbsp;Int,&nbsp;b:&nbsp;Int)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;sum(x&nbsp;=&gt;&nbsp;x,&nbsp;a,&nbsp;b)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;sumCubes(a:&nbsp;Int,&nbsp;b:&nbsp;Int)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;sum(x&nbsp;=&gt;&nbsp;x*x*x,&nbsp;a,&nbsp;b)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;sumFactorials(a:&nbsp;Int,&nbsp;b:&nbsp;Int)&nbsp;=&nbsp;sum(fact,&nbsp;a,&nbsp;b)</span></span></div></pre></div>\n<p>위의 함수들에서 a, b 파라미터는 sumInts(), sum()에서 반복된다. 이를 제거하여 함수를 더 간소하게 만드는 방법은 무엇일까?\n우선 아래의 함수를 살펴보자.</p>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;sum(f:&nbsp;Int&nbsp;=&gt;&nbsp;Int):&nbsp;(Int,&nbsp;Int)&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;{</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;def&nbsp;sumF(a:&nbsp;Int,&nbsp;b:&nbsp;Int):&nbsp;Int&nbsp;=&nbsp;{</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(a&nbsp;&gt;&nbsp;b)&nbsp;0</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;f(a)&nbsp;+&nbsp;sumF(a+1,&nbsp;b)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;}</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;sumF</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>}</span></span></div></pre></div>\n<p>기존에 봤던 sum() 함수와 조금 다르게 생겼다. 우선 sum() 함수의 파라미터가 f() 하나로 줄었고, sum() 함수는 (Int, Int) => Int 와 같은 타입의 익명함수를 리턴하고 있다.\nsumF 를 호출하는 부분이 조금 이해하기 어려운데, 위의 내부함수 sumF()를 자세히 보면 익명함수를 설명했을 때의 형태와 같다는 것을 알 수 있다.</p>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>(x:&nbsp;Int,&nbsp;y:&nbsp;Int):&nbsp;Int&nbsp;=&gt;&nbsp;x&nbsp;*&nbsp;y</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>//&nbsp;이&nbsp;익명함수는&nbsp;아래와&nbsp;같이&nbsp;표현가능하다.</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;f(x:&nbsp;Int):&nbsp;Int&nbsp;=&nbsp;x&nbsp;*&nbsp;y;&nbsp;f</span></span></div></pre></div>\n<p>위에서 썼던 sumInts(), sumCubes(), sumFactorials() 함수들을 가져오자. 조금 다르다. sum() 함수의 파라미터가 f 하나로 줄면서 아래의 각 함수들도 sum() 호출부의 인자가 익명함수 하나만 남았다.</p>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;sumInts(a:&nbsp;Int,&nbsp;b:&nbsp;Int)&nbsp;=&nbsp;sum(x&nbsp;=&gt;&nbsp;x)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;sumCubes(a:&nbsp;Int,&nbsp;b:&nbsp;Int)&nbsp;=&nbsp;sum(x&nbsp;=&gt;&nbsp;x*x*x)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;sumFactorials(a:&nbsp;Int,&nbsp;b:&nbsp;Int)&nbsp;=&nbsp;sum(fact)</span></span></div></pre></div>\n<p>이제 sum() 함수는 함수를 리턴하고 있으므로, sumCubes(1, 10)를 호출하면</p>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>sumCubes(1,&nbsp;10)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>//&nbsp;res0:&nbsp;(Int,&nbsp;Int)&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function2&gt;</span></span></div></pre></div>\n<p>이는 또한 이렇게 바꿔 쓸수 있다.</p>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>sum&nbsp;(cube)&nbsp;(1,&nbsp;10)&nbsp;//&nbsp;multiple&nbsp;parameters</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>(sum&nbsp;(cube))&nbsp;(1,&nbsp;10)</span></span></div></pre></div>\n<p>위의 multiple parameters 를 적용하면 sum() 함수를 더 짧게 작성할 수 있다.</p>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;sum(f:&nbsp;Int&nbsp;=&gt;&nbsp;Int)(a:&nbsp;Int,&nbsp;b:&nbsp;Int):&nbsp;Int&nbsp;=</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;if&nbsp;(a&nbsp;&gt;&nbsp;b)&nbsp;0&nbsp;else&nbsp;f(a)&nbsp;+&nbsp;sum(f)(a+1,&nbsp;b)</span></span></div></pre></div>\n<p>여러개의 파라미터 list 를 가진 함수 f 에서 파라미터 list 의 개수가 1 보다 큰 경우 마지막 파라미터 list 를 f 함수에서 제거하면 이 마지막 파라미터 list 를 파라미터로 가지는 또다른 함수 g 를 만들 수 있다. 물론 이 g 함수는 f 함수의 리턴함수가 된다. 식으로 나타내면 다음과 같다. 참고로 각각의 식은 모두 동일하다</p>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;f(arg1)(arg2)(arg3)(arg4)&nbsp;=&nbsp;E</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;f(arg1)(arg2)(arg3)&nbsp;=&nbsp;{def&nbsp;g(arg4)&nbsp;=&nbsp;E;g}&nbsp;//&nbsp;arg4를&nbsp;이용해&nbsp;g함수&nbsp;생성</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;f(arg1)(arg2)(arg3)&nbsp;=&nbsp;(arg4&nbsp;=&gt;&nbsp;E)&nbsp;//&nbsp;g를&nbsp;익명함수로&nbsp;변경</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;f&nbsp;=&nbsp;(arg1&nbsp;=&gt;&nbsp;(arg2&nbsp;=&gt;&nbsp;(arg3&nbsp;=&gt;&nbsp;(arg4&nbsp;=&gt;&nbsp;E))))&nbsp;//&nbsp;파라미터를&nbsp;하나씩&nbsp;우측으로&nbsp;전달함</span></span></div></pre></div>\n<p>이와같은 형태의 함수정의를 curring 이라 부른다.</p>\n<h3>Excercise</h3>\n<p><em>Write a product function that calculates the product of the values of a function for the points on a given interval</em></p>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;product(f:&nbsp;Int&nbsp;=&gt;&nbsp;Int)(a:&nbsp;Int,&nbsp;b:&nbsp;Int):&nbsp;Int&nbsp;=&nbsp;{</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;if&nbsp;(a&nbsp;&gt;&nbsp;b)&nbsp;1&nbsp;else&nbsp;f(a)&nbsp;*&nbsp;product&nbsp;(f)(a+1,&nbsp;b)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>}</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>product(x&nbsp;=&gt;&nbsp;x*x)(3,4)</span></span></div></pre></div>\n<p><em>Write factorial in terms of product.</em></p>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;fact(n:&nbsp;Int):&nbsp;Int&nbsp;=&nbsp;product(x&nbsp;=&gt;&nbsp;x)(1,&nbsp;n)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>fact(4)</span></span></div></pre></div>\n<p><em>Can you write a more general funciton, which generalizes both sum and product?</em></p>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;mapReduce(f:&nbsp;Int&nbsp;=&gt;&nbsp;Int,&nbsp;combine:&nbsp;(Int,&nbsp;Int)&nbsp;=&gt;&nbsp;Int,&nbsp;zero:&nbsp;Int)(a:&nbsp;Int,&nbsp;b:&nbsp;Int):&nbsp;Int&nbsp;=&nbsp;{</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;if&nbsp;(a&nbsp;&gt;&nbsp;b)&nbsp;zero</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;else&nbsp;combine(f(a),&nbsp;mapReduce(f,&nbsp;combine,&nbsp;zero)(a+1,&nbsp;b))</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>}</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;productForMapReduce(f:&nbsp;Int&nbsp;=&gt;&nbsp;Int)(a:&nbsp;Int,&nbsp;b:&nbsp;Int):&nbsp;Int&nbsp;=&nbsp;mapReduce(f,&nbsp;(x,&nbsp;y)&nbsp;=&gt;&nbsp;x*y,&nbsp;1)(a,&nbsp;b)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>productForMapReduce(x&nbsp;=&gt;&nbsp;x*x)(3,&nbsp;4)</span></span></div></pre></div>\n<h2>2.3 Example: Finding Fixed Point</h2>\n<p>부동점 구하기, Fixed Point 라 함은 어떤 함수에서 고정적인 값을 갖는 point 를 말한다. 다음의 함수에서 2 는 부동점(고정점)이다.\n기하학적으로(?) 함수 f 의 부동점은 y = x 와 주어진 함수와의 교점이다. 즉, x 와 f(x) 값이 동일한 값을 뜻한다.</p>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>f(x)&nbsp;=&nbsp;x^2&nbsp;-3x&nbsp;+&nbsp;4</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>//&nbsp;2&nbsp;=&nbsp;4&nbsp;-&nbsp;6&nbsp;+&nbsp;4</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>//&nbsp;2&nbsp;=&nbsp;2,&nbsp;부동점</span></span></div></pre></div>\n<p>어떤 함수에 대해서 부동점을 구하는 함수 fixedPoint 는 아래와 같다.</p>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>object&nbsp;ex&nbsp;{</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;val&nbsp;tolerance&nbsp;=&nbsp;0.0001</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;def&nbsp;isCloseEnough(x:&nbsp;Double,&nbsp;y:&nbsp;Double)&nbsp;=</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;abs((x&nbsp;-&nbsp;y)&nbsp;/&nbsp;x)&nbsp;/&nbsp;x&nbsp;&lt;&nbsp;tolerance</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;def&nbsp;fixedPoint(f:&nbsp;Double&nbsp;=&gt;&nbsp;Double)(firstGuess:&nbsp;Double)&nbsp;=&nbsp;{</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;iterate(guess:&nbsp;Double):&nbsp;Double&nbsp;=&nbsp;{</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(&quot;guess&nbsp;=&nbsp;&quot;&nbsp;+&nbsp;guess)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;next&nbsp;=&nbsp;f(guess)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(isCloseEnough(guess,&nbsp;next))&nbsp;next</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;iterate(next)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;iterate(firstGuess)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;}</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;fixedPoint(x&nbsp;=&gt;&nbsp;1&nbsp;+&nbsp;x/2)(1)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;def&nbsp;sqrt(x:&nbsp;Double)&nbsp;=&nbsp;fixedPoint(y&nbsp;=&gt;&nbsp;x&nbsp;/&nbsp;y)(1)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;sqrt(2)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>}</span></span></div></pre></div>\n<p>fixedPoint 를 응용해보면, 첫번째 인자인 f 함수에 어떤 수식을 넣어 반복적으로 적용하면서 고정값을 찾아 가는 과정에 맞게 넣을 수 있겠다.\n마지막에 있는 것은 sqrt 를 구하는 함수는 바로 위에서 말한 반복을 통한 고정값 추론에 적합하다.\nsqrt y 를 구하려면 y * y = x 가 되기 때문에 함수 y = x / y 를 fixedPoint 함수에 반복적으로 적용하다보면 고정값 sqrt 의 근사치를 구할 수 있다.\n하지만, 실제로 위와같이 y => x / y 를 fixedPoint 의 함수 인자로 넣게 되면, 원하는 값을 얻지 못한다.\n왜냐하면, guess 값이 너무 심하게 변하기 때문에 발생하는 문제다. fixedPoint 의 내부함수 iterate 는 guess 와 next 가 교차하는 구조인데, 처음 sqrt(2)에서 2 는 x 이다.\n그리고 y 는 firstGuess 인 1 이되는데, 이 두 값이 f(x) = x / y 에 대입되면, f(x)는 2 가 된다. 다시 y 가 2 가 되고 x 가 2 이므로 iterate 함수를 한번 돌면 y 는 1 이된다.\n즉, 1,2,1,2 반복하기 때문에 무한루프에 빠지게 된다.\n이를 해결하기 위해서는 연속하는 두개의 값 즉 1 과 2 의 평균값(1.5)를 구함으로써 해결할 수 있다.</p>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>y&nbsp;=&gt;&nbsp;x&nbsp;/&nbsp;y</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>//&nbsp;아래와&nbsp;같이&nbsp;바꿔&nbsp;쓴다.</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>y&nbsp;=&gt;&nbsp;(y&nbsp;+&nbsp;x/y)&nbsp;/&nbsp;2</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>//&nbsp;코드에&nbsp;적용해보면</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;sqrt(x:&nbsp;Double)&nbsp;=&nbsp;fixedPoint(y&nbsp;=&gt;&nbsp;(y&nbsp;+&nbsp;x&nbsp;/&nbsp;y)&nbsp;/&nbsp;2)</span></span></div></pre></div>\n<p>위와 같이 평균을 내어서 안정화 시키는 기법을 AverageDamp 라고 한다.</p>\n<h2>2.4 Scala Syntax Summary</h2>\n<p>강의 참고</p>\n<h2>2.5 Functions and Data</h2>\n<p>유리수의 여러가지 연산을 바탕으로 함수를 만드는 방법과 데이터를 캡슐화하기 위해 클래스를 사용하는 방법을 알아 본다.</p>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>//&nbsp;class</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>class&nbsp;Rational(x:&nbsp;Int,&nbsp;y:&nbsp;Int)&nbsp;{</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;def&nbsp;numer&nbsp;=&nbsp;x</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;def&nbsp;denom&nbsp;=&nbsp;y</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;def&nbsp;add(that:&nbsp;Rational)&nbsp;=</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Rational(</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;*&nbsp;that.denom&nbsp;+&nbsp;that.numer&nbsp;*&nbsp;denom,</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;*&nbsp;that.denom)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>}</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>//&nbsp;object</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>val&nbsp;x&nbsp;=&nbsp;new&nbsp;Rational(1,&nbsp;2)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>x.numer&nbsp;&nbsp;//&nbsp;1</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>y.denom&nbsp;&nbsp;//&nbsp;2</span></span></div></pre></div>\n<p>위에서 Rational 클래스를 정의하였다. 클래스를 정의하면 두가지 요소가 정의되는데, 첫번째는 Rational 이라는 type 이 만들어진다는 것이고, 두번째는 x 와 y 를 인자로 가지는 Rational 이라는 생성자가 만들어진다는 것이다.\nobject 를 만드는 법은 Java 의 object 만드는 법과 동일하게 new 키워드를 사용해서 만들 수 있다.</p>\n<h3>Method</h3>\n<p>스칼라에서 함수(funciton)과 메소드(method)는 다른 의미로 사용되는데, 일반적으로 함수는 독립적인 객체로서 클래스처럼 인스턴스화 가능한 형태로 동작하는 반면, 메소드는 클래스내에 속하는 멤버로써 클래스 내의 데이터를 연산하는 역할을 한다. 실제 컴파일 해보면 차이를 알 수 있는데, 함수같은 경우에는 클래스로 변경되어 있지만(내부 함수인 경우에는 내부 클래스로 컴파일), 메소드는 컴파일 내에 멤버로만 존재하기 때문에 별도의 class 로 컴파일 되지 않는다.</p>\n<h3>Exerxise</h3>\n<ol>\n<li>\n<p>In your worksheet, add a method neg to class Rational that is used like this: x.neg</p>\n</li>\n<li>\n<p>Add a method sub to subtract two rational numbers.</p>\n</li>\n<li>\n<p>With the values of x, y, z as given in the previous slide, what is the result of x - y - z</p>\n</li>\n</ol>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>class&nbsp;Rational(x:&nbsp;Int,&nbsp;y:&nbsp;Int)&nbsp;{</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;def&nbsp;numer&nbsp;=&nbsp;x</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;def&nbsp;denom&nbsp;=&nbsp;y</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;def&nbsp;add(that:&nbsp;Rational)&nbsp;=</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Rational(</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;*&nbsp;that.denom&nbsp;+&nbsp;denom&nbsp;*&nbsp;that.numer,</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;*&nbsp;that.denom)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;def&nbsp;neg:&nbsp;Rational&nbsp;=&nbsp;new&nbsp;Rational(numer&nbsp;*&nbsp;-1,&nbsp;denom)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;def&nbsp;sub(that:&nbsp;Rational):&nbsp;Rational&nbsp;=&nbsp;add(that.neg)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;override&nbsp;def&nbsp;toString&nbsp;=&nbsp;numer&nbsp;+&nbsp;&quot;/&quot;&nbsp;+&nbsp;denom</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>}</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>val&nbsp;x&nbsp;=&nbsp;new&nbsp;Rational(1,&nbsp;3)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>val&nbsp;y&nbsp;=&nbsp;new&nbsp;Rational(5,&nbsp;7)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>val&nbsp;z&nbsp;=&nbsp;new&nbsp;Rational(3,&nbsp;2)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>x.sub(y).sub(z)&nbsp;//&nbsp;res0:&nbsp;Rational&nbsp;=&nbsp;-79/42</span></span></div></pre></div>\n<h2>2.6 More Fun With Rationals</h2>\n<p>2.5 에서 구현한 Rational 클래스는 분모와 분자를 나누어진 형태로 출력하지 않는 문제가 있다. 그래서 이전에 사용했었던 최대 공약수를 구하는 함수인 gcd 를 메서드 형태로 Rational 클래스에 추가해준다.\n그리고 클래스의 인수인 x 와 y 에 두 변수의 gcd 값을 나누어준다.</p>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>class&nbsp;Rational(x:&nbsp;Int,&nbsp;y:&nbsp;Int)&nbsp;{</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;private&nbsp;def&nbsp;gcd(a:&nbsp;Int,&nbsp;b:&nbsp;Int):&nbsp;Int&nbsp;=&nbsp;if&nbsp;(b&nbsp;==&nbsp;0)&nbsp;a&nbsp;else&nbsp;gcd(b,&nbsp;a&nbsp;%&nbsp;b)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;//&nbsp;ex&nbsp;1)&nbsp;g를&nbsp;재사용하는&nbsp;방법</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;private&nbsp;val&nbsp;g&nbsp;=&nbsp;gcd(x,&nbsp;y)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;def&nbsp;numer&nbsp;=&nbsp;x&nbsp;/&nbsp;g</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;def&nbsp;denom&nbsp;=&nbsp;y&nbsp;/&nbsp;g</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;//&nbsp;ex&nbsp;2)&nbsp;numer와&nbsp;denom이&nbsp;자주&nbsp;호출되지&nbsp;않을때는&nbsp;gcd를&nbsp;직접&nbsp;넣어줌</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;def&nbsp;numer&nbsp;=&nbsp;x&nbsp;/&nbsp;gcd(x,&nbsp;y)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;def&nbsp;denom&nbsp;=&nbsp;y&nbsp;/&nbsp;gcd(x,&nbsp;y)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;//&nbsp;ex3)&nbsp;이&nbsp;두&nbsp;변수는&nbsp;한번만&nbsp;연산하도록&nbsp;하기&nbsp;위해&nbsp;메서드를&nbsp;value로&nbsp;변경,&nbsp;numer와&nbsp;denom이&nbsp;자주&nbsp;call&nbsp;되는&nbsp;경우에&nbsp;적합</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;val&nbsp;numer&nbsp;=&nbsp;x&nbsp;/&nbsp;gcd(x,&nbsp;y)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;val&nbsp;denom&nbsp;=&nbsp;y&nbsp;/&nbsp;gcd(x,&nbsp;y)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;...</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>}</span></span></div></pre></div>\n<h3>this</h3>\n<p>this 키워드는 java 와 동일하게 사용된다. this 는 현재 메소드가 실행되고있는 object 를 말한다. second 생성자를 만들때에도</p>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>def&nbsp;this(x:&nbsp;Int)&nbsp;=&nbsp;this(x,&nbsp;1)</span></span></div></pre></div>\n<p>과 같이 사용한다.</p>\n<h3>require 키워드</h3>\n<p>require 키워드를 사용하면 클래스의 인자값 등에 대한 제약을 만들 수 있다. 아래의 클래스가 있는 상태에서 만약에 new Rational(1, 0)과 같은 instance 를 생성하게 되면 예외가 발생하게 된다. require 와 같이 객체가 생성될때 강제로 호출하는 역할을 하는 함수를 predefined funciton 이라고 한다.</p>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>class&nbsp;Rational(x:&nbsp;Int,&nbsp;y:&nbsp;Int)&nbsp;{</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;require(y&nbsp;!=&nbsp;0,&nbsp;&quot;&nbsp;denominator&nbsp;must&nbsp;be&nbsp;positive&quot;)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;...</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>}</span></span></div></pre></div>\n<h2>2.7 Evaluation and Operators</h2>\n<p>클래스와 메소드의 evalutaion 과정</p>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>class&nbsp;C(x1,&nbsp;...,&nbsp;xm)&nbsp;{...&nbsp;def&nbsp;f(y1,&nbsp;...,&nbsp;yn)&nbsp;=&nbsp;b&nbsp;...}</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>new&nbsp;C(v1,&nbsp;...,&nbsp;vm).f(w1,&nbsp;...,&nbsp;wn)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>//&nbsp;substitution</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>[w1/y1,&nbsp;...&nbsp;wn/yn][v1/x1,&nbsp;...,&nbsp;vm/xm][new&nbsp;C(v1,&nbsp;...,&nbsp;vm)/this]b</span></span></div></pre></div>\n<p>과정을 간단히 요약하면</p>\n<ol>\n<li>f 메서드의 formal parameters(y1, ..., yn)이 arguments(w1, ..., wn)으로 치환</li>\n<li>클래스의 formal parameters(x1, ..., xm)이 arguments(v1, ..., vm)으로 치환</li>\n<li>self reference this 가 new C(v1, ..., vm)으로 치환</li>\n</ol>\n<p>만약 f 함수 내부에서 this 가 사용된다고 가정한다면, 이 this 는 이미 new C(v1, ..., vm)으로 치환된 value 이므로, 해당 object 자체를 참조하는 값이 된다.</p>\n<h3>Operators</h3>\n<p>일반적인 언어에서는 r.add(s)와 같은 함수가 호출될때 자연수인 경우에는 r + s 와 같이 바꿔 쓸 수 있지만, 유리수의 경우에는 불가하다.\n하지만 스칼라에서는 오퍼레이터 기호를 함수 이름으로 사용가능하다.</p>\n<ul>\n<li>step 1 : r.add(s) ==> r add s</li>\n<li>step 2 : def + (that: Rational) = { ... }</li>\n</ul>\n<p>하지만 위와 같이 함수 이름을 오퍼레이터로 사용하게 되면, 우선순위 문제가 발생할 수 있다.\n그래서 스칼라에서는 precedence rules 을 별도로 만들어 두었다.\n우선순위는 아래가 제일 높고 위로 갈수록 낮아진다.</p>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>(all&nbsp;letters)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>|</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>^</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&amp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&lt;&nbsp;&gt;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>=&nbsp;!</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>:</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>+&nbsp;-</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>*&nbsp;/&nbsp;%</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>(all&nbsp;other&nbsp;special&nbsp;characters)</span></span></div></pre></div>","frontmatter":{"title":"Functional Programming in Scala week 2","date":"July 26, 2016"}}},"pageContext":{"slug":"/2016/07/26/functional-programming-in-scala-week2/","previous":{"fields":{"slug":"/2016/07/26/functional-programming-in-scala-week1/"},"frontmatter":{"title":"Functional Programming in Scala week 1"}},"next":{"fields":{"slug":"/2016/07/26/functional-programming-in-scala-week3/"},"frontmatter":{"title":"Functional Programming in Scala week 3"}}}}