{"data":{"site":{"siteMetadata":{"title":"bono's blog","author":"bono"}},"markdownRemark":{"id":"84cac1d3-14e5-525b-ba77-22917c54a28c","excerpt":"장고 프로젝트는 다양한 방법으로 구현이 가능합니다.\n그 중에서 view…","html":"<p>장고 프로젝트는 다양한 방법으로 구현이 가능합니다.\n그 중에서 view 에서 처리할 수 있는 방법으로 크게 두 가지가 있는데,\n하나는 함수를 기반으로 만드는 방법, 그리고 또 한가지는 클래스를 기반으로 만드는 방법입니다.</p>\n<p>지금까지 장고를 사용하면서 느꼈던 두 방법의 차이점은(지극히 개인적인 견해입니다),\n함수를 기반으로 만드는 방법은 쉽고 빠르게 만들 수 있지만 확장성이 떨어지고,\n클래스를 기반으로 만드는 방법은 함수를 기반으로 만드는 방법에 비해서 시간이 좀 더 필요하지만 확장성 면에서는 훨씬 뛰어나다는 것입니다.\n그 중 클래스 기반의 방법의 확장성을 극대화 시켜주는 녀석이 바로 Mixin 이라는 놈입니다.\nMixin 이라는 개념은 루비와 같은 타 언어에서도 많이 쓰이고 있는데, 클래스에 부가적인 기능이나 정보를 추가해주기 위한 모듈을 뜻합니다.\n함수 기반으로 만든 앱 같은 경우에 추가적인 기능이 필요하면 코드를 직접 구현하거나, 함수를 덧붙이는 형태가 되야할 것입니다.\n반면에 클래스의 경우에는 추가적인 기능이 필요하때 Mixin 을 추가하면 간단히 해결됩니다.\n몇 개를 추가해도 상관없으며 클래스에 의존적이지 않기 때문에 확장성 면에서 굉장히 자유롭다 할 수 있습니다.</p>\n<p>루비 언어에서의 믹스인은 다중 상속이 지원되지 않아 이를 해결하기 위한 방안으로 등장했다고 볼 수 있는데요.\n파이썬처럼 다중상속이 지원되는 언어에서 굳이 Mixin(실제로는 다중상속)이라는 개념이 따로 있는 이유는,\n다중상속이 주는 모호함을 피하기 위함이라는 생각이듭니다.\n명확하게 기능을 암시하는 이름(mixin)을 줌으로써 상속받는 클래스와 혼동하지 않도록 하는 것이죠.</p>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>class&nbsp;FirstMixin(object):</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;test1(self):</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;first&nbsp;mixin!!!&quot;)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>class&nbsp;SecondMixin(object):</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;test2(self):</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;second&nbsp;mixin!!!&quot;)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>class&nbsp;TestClass(ParentClass,&nbsp;FirstMixin,&nbsp;SecondMixin):</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;pass</span></span></div></pre></div>\n<p>위의 코드에서도 알 수 있듯이 믹스인이라는 것은 상속받는 ParentClass 와 다를 것 없는 클래스입니다.\n이렇게 TestClass 는 실제로 ParentClass, FirstMixin, SecondMixin 이라는 세가지 클래스를 상속하는 것이지만,\nParentClass 를 상속하고 FirstMixin 과 SecondMixin 의 기능을 추가로 확장한 것이라 말할 수 있습니다.</p>\n<p>그렇다면, 장고(django)에서는 믹스인을 어떻게 사용하고 있을까요?\n대표적으로 View 같은 경우가 믹스인을 많이 사용하고 있는데요.\n예를 한번 살펴보겠습니다.</p>\n<h3>views.py</h3>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>from&nbsp;django.views.generic&nbsp;import&nbsp;TemplateView</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>class&nbsp;TestTemplateView(TemplateView):</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;template_name&nbsp;=&nbsp;&quot;test.html&quot;</span></span></div></pre></div>\n<p>views.py 는 urls.py 에서 호출되는 url 에 매핑된 클래스(또는 메서드)를 모아놓은 파일입니다\n(기본파일일뿐 반드시 views.py 에 있을 필요는 없습니다.)\n보통 클래스들은 View 를 상속받아서 나머지 코드를 구현하지만,\n장고는 개발자들의 편의를 위해 몇가지 유용한 View 를 만들어 두었습니다.</p>\n<p>가장 쉬운 예로 TemplateView 라는 클래스가 있습니다.\n이 클래스는 template_name 이라는 변수에 template 파일명(또는 패스)만 넣어주면,\n클라이언트로부터 호출된 요청을 처리할 수 있습니다.\n별다른 로직은 없고 다만, 해당 temlate 으로 화면을 이동하는 역할을 할 뿐입니다.</p>\n<p>어떻게 이런게 가능한지를 보기위해 TemplateView 를 열어봅니다.</p>\n<h3>generic/base.py</h3>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>class&nbsp;TemplateView(TemplateResponseMixin,&nbsp;ContextMixin,&nbsp;View):</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;view&nbsp;that&nbsp;renders&nbsp;a&nbsp;template.&nbsp;&nbsp;This&nbsp;view&nbsp;will&nbsp;also&nbsp;pass&nbsp;into&nbsp;the&nbsp;context</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;any&nbsp;keyword&nbsp;arguments&nbsp;passed&nbsp;by&nbsp;the&nbsp;url&nbsp;conf.</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;get(self,&nbsp;request,&nbsp;*args,&nbsp;**kwargs):</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context&nbsp;=&nbsp;self.get_context_data(**kwargs)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;self.render_to_response(context)</span></span></div></pre></div>\n<p>주석을 대충 해석해보면,</p>\n<blockquote>\n<p>template 을 그려주는 view 이다. 또한 이 view 는 url conf 를 통해서 kwargs 에 어떠한 값이라도 context 를 추가해줄수 있다.</p>\n</blockquote>\n<p>TemplateView 는 위와 같이 세가지 클래스를 상속받고 있습니다.\nTempalteResponseMixin, ContextMixin 그리고 View 입니다.\n여기에 바로 우리가 찾고 있던 mixin 이 있습니다!!</p>\n<p>기본적으로 사용되는 View 에다가 기능을 확장하기 위해 두가지 mixin 을 덧붙였습니다.\n그럼 각 믹스인이 어떤 역할을 하는지 살펴보겠습니다.</p>\n<h3>TemplateResponseMixin</h3>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>class&nbsp;TemplateResponseMixin(object):</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;template_name&nbsp;=&nbsp;None</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;template_engine&nbsp;=&nbsp;None</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;response_class&nbsp;=&nbsp;TemplateResponse</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;content_type&nbsp;=&nbsp;None</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;render_to_response(self,&nbsp;context,&nbsp;**response_kwargs):</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response_kwargs.setdefault(&#39;content_type&#39;,&nbsp;self.content_type)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;self.response_class(</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request=self.request,</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;template=self.get_template_names(),</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context=context,</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;using=self.template_engine,</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**response_kwargs</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;get_template_names(self):</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self.template_name&nbsp;is&nbsp;None:</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;ImproperlyConfigured(</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;TemplateResponseMixin&nbsp;requires&nbsp;either&nbsp;a&nbsp;definition&nbsp;of&nbsp;&quot;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&#39;template_name&#39;&nbsp;or&nbsp;an&nbsp;implementation&nbsp;of&nbsp;&#39;get_template_names()&#39;&quot;)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;[self.template_name]</span></span></div></pre></div>\n<p>TemplateView 에서</p>\n<blockquote>\n<p>return self.render<em>to</em>response(context)</p>\n</blockquote>\n<p>위의 부분이 호출하면, 실제로 TemplateResponseMixin 클래스의 render<em>to</em>response(context)가 호출됩니다.\n이 메서드는 request, template, context 등을 세팅한 다음 TemplateResponse 클래스를 리턴하게 됩니다.\nTemplateResponse 클래스에 대해서 자세히 설명하진 않겠지만,\n간략히 설명하면 get 메서드에서 리턴할때 template 과 context 를 실어서 클라이언트에 응답을 보내는 역할을 합니다.</p>\n<p>결과적으로 TemplateView 에서는 template 변수만 설정하면(request 는 get 메서드에서 가져옴, context 는 ContextMixin 에서 가져옴)\n응답에 필요한 모든 값을 설정하여 클라이언트에 응답을 보낼수 있게 되는 것입니다.</p>\n<h3>ContextMixin</h3>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>class&nbsp;ContextMixin(object):</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;get_context_data(self,&nbsp;**kwargs):</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;&#39;view&#39;&nbsp;not&nbsp;in&nbsp;kwargs:</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kwargs[&#39;view&#39;]&nbsp;=&nbsp;self</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;kwargs</span></span></div></pre></div>\n<p>TemplateResponseMixin 에서 설명했듯이 context 를 가져오기 위한 역할을 하는것이 ContextMixin 입니다.\ncontext 는, 클라이언트에 응답을 보낼 때 keyword argument(dict)로 값을 실어서 보낼 수 있는 역할을 하는 변수입니다(이름도 바꿀 수 있음).\nTemplateView 의 구현부분을 살펴보면,</p>\n<blockquote>\n<p>context = self.get<em>context</em>data(**kwargs)</p>\n</blockquote>\n<p>바로 이 부분을 통해서 context 를 생성하여 클라이언트에 보낼 수 있게 됩니다.\n만약 views.py 구현부에서 추가적으로 context 에 추가할 필요가 있을때는\n아래처럼 오버라이딩하여 context 를 추가해주면 됩니다.</p>\n<h3>views.py - 2</h3>\n<div class='midnight'><pre class=\"editor editor-colors\"><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>from&nbsp;django.views.generic&nbsp;import&nbsp;TemplateView</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>class&nbsp;TestTemplateView(TemplateView):</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;template_name&nbsp;=&nbsp;&quot;test.html&quot;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;get_context_data(self,&nbsp;**kwargs):</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context&nbsp;=&nbsp;super(TestTemplateView,&nbsp;self).get_context_data(**kwargs)</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context[&#39;extra_value&#39;]&nbsp;=&nbsp;100</span></span></div><div class=\"line\"><span class=\"syntax--text syntax--plain syntax--null-grammar\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;context</span></span></div></pre></div>\n<p>믹스인은 사용함에 따라서 거의 무한하게 확장할 수 있습니다.\nTemplateView 와 같이 기능이 단순한 경우에는 두개 정도의 믹스인만 사용되었지만,\nListView 같은 View 들은 TemplateView 보다 다양하고 복잡한 믹스인을 사용하여 기능을 확장시켰습니다.\n검색해보면, ListView 외에도 대부분의 확장된 View 들이 믹스인을 확장하여 다양한 기능을 가지는 View 를 만들어 내고 있습니다.</p>\n<p>이처럼 믹스인을 잘 이용하면 자기 입맛에 딱 맞는 CustomView 를 만드는데 큰 도움이 될 수 있습니다.</p>","frontmatter":{"title":"[django] Mixin을 이용한 View 확장하기","date":"March 08, 2016"}}},"pageContext":{"slug":"/2016/03/08/django-extend-view-using-mixin/","previous":{"fields":{"slug":"/2016/03/06/django-unit-test-without-testdb/"},"frontmatter":{"title":"[django] 테스트DB 없이 유닛테스트(unit test)하기"}},"next":{"fields":{"slug":"/2016/07/26/functional-programming-in-scala-week1/"},"frontmatter":{"title":"Functional Programming in Scala week 1"}}}}